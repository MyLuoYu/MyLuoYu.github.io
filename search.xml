<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hadoop搭建调优笔记</title>
    <url>/Hadoop%E6%90%AD%E5%BB%BA%E8%B0%83%E4%BC%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>    在虚拟机上搭建简单的Hadoop学习环境，含脚本、配置文件</p>
<span id="more"></span>

<h2 id="Hadoop环境搭建"><a href="#Hadoop环境搭建" class="headerlink" title="Hadoop环境搭建"></a>Hadoop环境搭建</h2><h3 id="准备模板机"><a href="#准备模板机" class="headerlink" title="准备模板机"></a>准备模板机</h3><blockquote>
<p>选择系统：Centos最小化换安装</p>
<p>以下操作均处于user（luo）用户下进行，操作必须保持操作用户统一。</p>
</blockquote>
<h4 id="下载vim、net-tools、rsync"><a href="#下载vim、net-tools、rsync" class="headerlink" title="下载vim、net-tools、rsync"></a>下载vim、net-tools、rsync</h4><blockquote>
<p>vim用于编写文件</p>
<p>rsync用于传输文件</p>
<p>net-tools用于查看网络</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install net-tools.x86_64 </span><br><span class="line">sudo yum install rsync </span><br><span class="line">sudo yum install vim</span><br></pre></td></tr></table></figure>

<h4 id="配置静态网络"><a href="#配置静态网络" class="headerlink" title="配置静态网络"></a>配置静态网络</h4><blockquote>
<p>系统版本不同ifcfg-eth0文件可能存在不一致</p>
<p>如ifcfg-ens33等，但文件内容相同</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/sysconfig/network-scripts/ifcfg-eth0 </span><br></pre></td></tr></table></figure>

<blockquote>
<p>BOOTPROTO&#x3D;”static”    网络设置为静态</p>
<p>IPADDR&#x3D;192.168.122.100    ip设置    网段必需一致（当前网段为122）<br>GATEWAY&#x3D;192.168.122.1    网关设置<br>DNS1&#x3D;192.168.122.1    DNS设置</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">PROXY_METHOD=&quot;none&quot;</span><br><span class="line">BROWSER_ONLY=&quot;no&quot;</span><br><span class="line">BOOTPROTO=&quot;static&quot;</span><br><span class="line">DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV4_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">IPV6_DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV6_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;</span><br><span class="line">NAME=&quot;eth0&quot;</span><br><span class="line">UUID=&quot;0980c27a-83b0-40da-a492-e1ea5164aa1c&quot;</span><br><span class="line">DEVICE=&quot;eth0&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br><span class="line"></span><br><span class="line">IPADDR=192.168.122.100</span><br><span class="line">GATEWAY=192.168.122.1</span><br><span class="line">DNS1=192.168.122.1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重启IP网络</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service network restart</span><br></pre></td></tr></table></figure>

<h4 id="配置映射和主机名"><a href="#配置映射和主机名" class="headerlink" title="配置映射和主机名"></a>配置映射和主机名</h4><blockquote>
<p>进入hosts文件编辑</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在文档中添加，将来要加入集群的ip及其名称</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line"></span><br><span class="line">192.168.122.100 hadoop100</span><br><span class="line">192.168.122.102 hadoop102</span><br><span class="line">192.168.122.103 hadoop103</span><br><span class="line">192.168.122.104 hadoop104</span><br></pre></td></tr></table></figure>

<blockquote>
<p>进入hostname文件编辑</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/hostname</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除原先主机名称</p>
<p>修改为自定义主机名称</p>
<p>本机为hadoop100</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hadoop100</span><br></pre></td></tr></table></figure>

<h4 id="关闭防火墙和开机自启"><a href="#关闭防火墙和开机自启" class="headerlink" title="关闭防火墙和开机自启"></a>关闭防火墙和开机自启</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld.service</span><br></pre></td></tr></table></figure>

<h4 id="user（luo）用户权限设置"><a href="#user（luo）用户权限设置" class="headerlink" title="user（luo）用户权限设置"></a>user（luo）用户权限设置</h4><blockquote>
<p>配置luo用户具有root权限，方便后期加sudo执行root权限的命令</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/sudoers</span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改&#x2F;etc&#x2F;sudoers文件，在%wheel这行下面添加一行，如下所示：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## Allow root to run any commands anywhere</span><br><span class="line">root    ALL=(ALL)     ALL</span><br><span class="line"></span><br><span class="line">## Allows people in group wheel to run all commands</span><br><span class="line">%wheel  ALL=(ALL)       ALL</span><br><span class="line">luo   ALL=(ALL)     NOPASSWD:ALL</span><br></pre></td></tr></table></figure>

<h4 id="创建目录并修改目录所有者"><a href="#创建目录并修改目录所有者" class="headerlink" title="创建目录并修改目录所有者"></a>创建目录并修改目录所有者</h4><blockquote>
<p>创建目录</p>
<p>module：存放软件</p>
<p>software：存放软件包</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir /opt/module/ /opt/software/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改目录所有者</p>
<p>当前用户为luo</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chown luo:luo /opt/module/ /opt/software/</span><br></pre></td></tr></table></figure>

<h4 id="安装jdk和hadoop及其环境配置"><a href="#安装jdk和hadoop及其环境配置" class="headerlink" title="安装jdk和hadoop及其环境配置"></a>安装jdk和hadoop及其环境配置</h4><blockquote>
<p>创建配置文件</p>
<p>系统中的profile配置文件会遍历profile.d下的所有.sh文件</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/profile.d/my_env.sh</span><br></pre></td></tr></table></figure>

<blockquote>
<p>编写配置文件</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">JAVA_HOME</span></span><br><span class="line">export JAVA_HOME=/opt/module/jdk-11</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">HADOOP_HOME</span></span><br><span class="line">export HADOOP_HOME=/opt/module/hadoop-3.3.1</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/bin</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/sbin</span><br></pre></td></tr></table></figure>

<h3 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h3><blockquote>
<p>环境：</p>
<ol>
<li>3台由hadoop100克隆的虚拟机</li>
<li>配置3台虚拟机的静态网络和主机名（102、103、104）</li>
<li>接下来的操作以hadoop102为主机</li>
<li>hadoopxxx是hosts的映射ip</li>
</ol>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line">ssh-copy-id hadoop102</span><br><span class="line">ssh-copy-id hadoop103</span><br><span class="line">ssh-copy-id hadoop104</span><br></pre></td></tr></table></figure>

<h3 id="Hadoop集群配置"><a href="#Hadoop集群配置" class="headerlink" title="Hadoop集群配置"></a>Hadoop集群配置</h3><blockquote>
<p>hadoop有以下4个文件需要配置：</p>
<ol>
<li>core-site.xml</li>
<li>hdfs-site.xml</li>
<li>mapred-site.xml</li>
<li>yarn-site.xml</li>
<li>workers</li>
</ol>
<p>进入文件所在目录进行配置</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt/module/hadoop-3.3.1/etc/hadoop/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在</p>
<configuration>

</configuration>

<p>标签内填写配置内容</p>
<p>必需在标签内填写配置内容！</p>
</blockquote>
<h4 id="core-site-xml"><a href="#core-site-xml" class="headerlink" title="core-site.xml"></a>core-site.xml</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- 指定NameNode的地址 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop102:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 指定hadoop数据的存储目录 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/module/hadoop-3.3.1/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 配置HDFS网页登录使用的静态用户为luo --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.http.staticuser.user<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">value</span>&gt;</span>luo<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 配置该luo(superUser)允许通过代理访问的主机节点 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.proxyuser.luo.hosts<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>*<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 配置该luo(superUser)允许通过代理用户所属组 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.proxyuser.luo.groups<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">value</span>&gt;</span>*<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 配置该luo(superUser)允许通过代理的用户--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.proxyuser.luo.users<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>*<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="hdfs-site-xml"><a href="#hdfs-site-xml" class="headerlink" title="hdfs-site.xml"></a>hdfs-site.xml</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- nn web端访问地址--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop102:9870<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2nn web端访问地址--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop104:9868<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 测试环境指定HDFS副本的数量1 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="yarn-site-xml"><a href="#yarn-site-xml" class="headerlink" title="yarn-site.xml"></a>yarn-site.xml</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 指定MR走shuffle --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 指定ResourceManager的地址--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop103<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 环境变量的继承 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.env-whitelist<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAPRED_HOME<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- yarn容器允许分配的最大最小内存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.minimum-allocation-mb<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>512<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.maximum-allocation-mb<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>4096<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- yarn容器允许管理的物理内存大小 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.resource.memory-mb<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>4096<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 关闭yarn对虚拟内存的限制检查 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.vmem-check-enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 开启日志聚集功能 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log-aggregation-enable<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置日志聚集服务器地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log.server.url<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>http://hadoop102:19888/jobhistory/logs<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置日志保留时间为7天 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log-aggregation.retain-seconds<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>604800<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="mapred-site-xml"><a href="#mapred-site-xml" class="headerlink" title="mapred-site.xml"></a>mapred-site.xml</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 指定MapReduce程序运行在Yarn上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 历史服务器端地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop102:10020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 历史服务器web端地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop102:19888<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="workers"><a href="#workers" class="headerlink" title="workers"></a>workers</h4><blockquote>
<p>workers填写的是集群主机的映射</p>
<p>不能存在多余的字符，如空格或者回车</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hadoop102</span><br><span class="line">hadoop103</span><br><span class="line">hadoop104</span><br></pre></td></tr></table></figure>

<h3 id="分发hadoop以及启动"><a href="#分发hadoop以及启动" class="headerlink" title="分发hadoop以及启动"></a>分发hadoop以及启动</h3><blockquote>
<p>为方便管理，使用了脚本进行分发与启动</p>
<ol>
<li>jpsall    （查看集群状态）  </li>
<li>myhadoop.sh     （对集群操作管理）</li>
<li>xsync        （分发脚本）</li>
</ol>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xsync /opt/module/hadoop-3.3.1/</span><br></pre></td></tr></table></figure>

<h4 id="格式化NameNode"><a href="#格式化NameNode" class="headerlink" title="格式化NameNode"></a>格式化NameNode</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt/module/hadoop-3.3.1</span><br><span class="line">hdfs namenode -format</span><br></pre></td></tr></table></figure>

<h4 id="启动hadoop"><a href="#启动hadoop" class="headerlink" title="启动hadoop"></a>启动hadoop</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">myhadoop.sh start</span><br></pre></td></tr></table></figure>

<h3 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h3><blockquote>
<p>centos系统&#x2F;home&#x2F;user(luo)&#x2F;bin目录默认添加到PATH，其他版本需要手动添加环境PATH</p>
<p>在必需在创建的bin目录下编写脚本 或者 自己添加到PATH的目录</p>
</blockquote>
<p>创建bin目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir ~/bin</span><br></pre></td></tr></table></figure>

<h4 id="xcall"><a href="#xcall" class="headerlink" title="xcall"></a>xcall</h4><blockquote>
<p>集群群发命令</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> host <span class="keyword">in</span> hadoop102 hadoop103 hadoop104</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> =============== <span class="variable">$host</span> ===============</span><br><span class="line">        ssh <span class="variable">$host</span> <span class="string">&quot;$*&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h4 id="jpsall"><a href="#jpsall" class="headerlink" title="jpsall"></a>jpsall</h4><blockquote>
<p>映射：按要求更改</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">for host in hadoop102 hadoop103 hadoop104</span><br><span class="line">do</span><br><span class="line">        echo =============== $host ===============</span><br><span class="line">        ssh $host jps</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h4 id="myhadoop-sh"><a href="#myhadoop-sh" class="headerlink" title="myhadoop.sh"></a>myhadoop.sh</h4><blockquote>
<p>映射、路径：按要求更改</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">if [ $# -lt 1 ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;No Args Input...&quot;</span><br><span class="line">    exit ;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line">&quot;start&quot;)</span><br><span class="line">        echo &quot; =================== 启动 hadoop集群 ===================&quot;</span><br><span class="line"></span><br><span class="line">        echo &quot; --------------- 启动 hdfs ---------------&quot;</span><br><span class="line">        ssh hadoop102 &quot;/opt/module/hadoop-3.3.1/sbin/start-dfs.sh&quot;</span><br><span class="line">        echo &quot; --------------- 启动 yarn ---------------&quot;</span><br><span class="line">        ssh hadoop103 &quot;/opt/module/hadoop-3.3.1/sbin/start-yarn.sh&quot;</span><br><span class="line">        echo &quot; --------------- 启动 historyserver ---------------&quot;</span><br><span class="line">        ssh hadoop102 &quot;/opt/module/hadoop-3.3.1/bin/mapred --daemon start historyserver&quot;</span><br><span class="line">;;</span><br><span class="line">&quot;stop&quot;)</span><br><span class="line">        echo &quot; =================== 关闭 hadoop集群 ===================&quot;</span><br><span class="line"></span><br><span class="line">        echo &quot; --------------- 关闭 historyserver ---------------&quot;</span><br><span class="line">        ssh hadoop102 &quot;/opt/module/hadoop-3.3.1/bin/mapred --daemon stop historyserver&quot;</span><br><span class="line">        echo &quot; --------------- 关闭 yarn ---------------&quot;</span><br><span class="line">        ssh hadoop103 &quot;/opt/module/hadoop-3.3.1/sbin/stop-yarn.sh&quot;</span><br><span class="line">        echo &quot; --------------- 关闭 hdfs ---------------&quot;</span><br><span class="line">        ssh hadoop102 &quot;/opt/module/hadoop-3.3.1/sbin/stop-dfs.sh&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">    echo &quot;Input Args Error...&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<h4 id="xsync"><a href="#xsync" class="headerlink" title="xsync"></a>xsync</h4><blockquote>
<p>映射：按要求更改</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1. 判断参数个数</span></span><br><span class="line">if [ $# -lt 1 ]</span><br><span class="line">then</span><br><span class="line">    echo Not Enough Arguement!</span><br><span class="line">    exit;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2. 遍历集群所有机器</span></span><br><span class="line">for host in hadoop102 hadoop103 hadoop104</span><br><span class="line">do</span><br><span class="line">    echo ====================  $host  ====================</span><br><span class="line">    #3. 遍历所有目录，挨个发送</span><br><span class="line"></span><br><span class="line">    for file in $@</span><br><span class="line">    do</span><br><span class="line">        #4. 判断文件是否存在</span><br><span class="line">        if [ -e $file ]</span><br><span class="line">            then</span><br><span class="line">                #5. 获取父目录</span><br><span class="line">                pdir=$(cd -P $(dirname $file); pwd)</span><br><span class="line"></span><br><span class="line">                #6. 获取当前文件的名称</span><br><span class="line">                fname=$(basename $file)</span><br><span class="line">                ssh $host &quot;mkdir -p $pdir&quot;</span><br><span class="line">                rsync -av $pdir/$fname $host:$pdir</span><br><span class="line">            else</span><br><span class="line">                echo $file does not exists!</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h4 id="kvm"><a href="#kvm" class="headerlink" title="kvm"></a>kvm</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/bin/zsh</span></span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line">&quot;-vm&quot;)</span><br><span class="line">    case $2 in</span><br><span class="line">    &quot;start&quot;)</span><br><span class="line">        echo &quot; =================== 启动虚拟机管理后台服务 ===================&quot;</span><br><span class="line">        sudo systemctl start libvirtd</span><br><span class="line">        echo &quot; =================== 启动 default NAT 网络 ===================&quot;</span><br><span class="line">        sudo virsh net-start default</span><br><span class="line">    ;;</span><br><span class="line">    &quot;status&quot;)</span><br><span class="line">        echo &quot; =================== 所以虚拟机状态 ===================&quot;</span><br><span class="line">        sudo virsh list --all</span><br><span class="line">    ;;</span><br><span class="line">    esac</span><br><span class="line">;;</span><br><span class="line">&quot;-hadoop&quot;)</span><br><span class="line">    case $2 in</span><br><span class="line">    &quot;start&quot;)</span><br><span class="line">        echo &quot; =================== 开启虚拟机：hadoop102 ===================&quot;</span><br><span class="line">        sudo virsh start hadoop102</span><br><span class="line">        echo &quot; =================== 开启虚拟机：hadoop103 ===================&quot;</span><br><span class="line">        sudo virsh start hadoop103</span><br><span class="line">        echo &quot; =================== 开启虚拟机：hadoop104 ===================&quot;</span><br><span class="line">        sudo virsh start hadoop104</span><br><span class="line"></span><br><span class="line">        sleep 15s</span><br><span class="line">        echo &quot; --------------- 启动 hdfs ---------------&quot;</span><br><span class="line">        ssh hadoop102 &quot;/opt/module/hadoop-3.3.1/sbin/start-dfs.sh&quot;</span><br><span class="line">        echo &quot; --------------- 启动 yarn ---------------&quot;</span><br><span class="line">        ssh hadoop103 &quot;/opt/module/hadoop-3.3.1/sbin/start-yarn.sh&quot;</span><br><span class="line">        echo &quot; --------------- 启动 historyserver ---------------&quot;</span><br><span class="line">        ssh hadoop102 &quot;/opt/module/hadoop-3.3.1/bin/mapred --daemon start historyserver&quot;</span><br><span class="line">    ;;</span><br><span class="line">    &quot;stop&quot;)</span><br><span class="line">        echo &quot; --------------- 关闭 historyserver ---------------&quot;</span><br><span class="line">        ssh hadoop102 &quot;/opt/module/hadoop-3.3.1/bin/mapred --daemon stop historyserver&quot;</span><br><span class="line">        echo &quot; --------------- 关闭 yarn ---------------&quot;</span><br><span class="line">        ssh hadoop103 &quot;/opt/module/hadoop-3.3.1/sbin/stop-yarn.sh&quot;</span><br><span class="line">        echo &quot; --------------- 关闭 hdfs ---------------&quot;</span><br><span class="line">        ssh hadoop102 &quot;/opt/module/hadoop-3.3.1/sbin/stop-dfs.sh&quot;</span><br><span class="line"></span><br><span class="line">        echo &quot; =================== 关闭虚拟机：hadoop102 ===================&quot;</span><br><span class="line">        sudo virsh shutdown hadoop102</span><br><span class="line">        echo &quot; =================== 关闭虚拟机：hadoop103 ===================&quot;</span><br><span class="line">        sudo virsh shutdown hadoop103</span><br><span class="line">        echo &quot; =================== 关闭虚拟机：hadoop104 ===================&quot;</span><br><span class="line">        sudo virsh shutdown hadoop104</span><br><span class="line">    ;;</span><br><span class="line">    &quot;status&quot;)</span><br><span class="line">        for host in hadoop102 hadoop103 hadoop104</span><br><span class="line">        do</span><br><span class="line">            echo =============== $host ===============</span><br><span class="line">            ssh $host jps</span><br><span class="line">        done</span><br><span class="line">    ;;</span><br><span class="line">    esac</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">    echo &quot;Input Args Error...&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<h4 id="赋予权限"><a href="#赋予权限" class="headerlink" title="赋予权限"></a>赋予权限</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x jpsall</span><br><span class="line">chmod +x myhadoop.sh</span><br><span class="line">chmod +x xsync</span><br></pre></td></tr></table></figure>

<h2 id="yarn笔记"><a href="#yarn笔记" class="headerlink" title="yarn笔记"></a>yarn笔记</h2><h3 id="Yarn的工作机制"><a href="#Yarn的工作机制" class="headerlink" title="Yarn的工作机制"></a>Yarn的工作机制</h3><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><ul>
<li>MR 程序提交到客户端所在的节点。</li>
<li>YarnRunner 向 ResourceManager 申请一个 Application。</li>
<li>RM 将该应用程序的资源路径返回给 YarnRunner。</li>
<li>该程序将运行所需资源提交到 HDFS 上。</li>
<li>程序资源提交完毕后，申请运行 mrAppMaster。</li>
<li>RM 将用户的请求初始化成一个 Task。</li>
<li>其中一个 NodeManager 领取到 Task 任务。</li>
<li>该 NodeManager 创建容器 Container，并产生 MRAppmaster。</li>
<li>Container 从 HDFS 上拷贝资源到本地。 </li>
<li>MRAppmaster 向 RM 申请运行 MapTask 资源。 </li>
<li>RM 将运行 MapTask 任务分配给另外两个 NodeManager，另两个 NodeManager 分 别领取任务并创建容器。</li>
<li>MR 向两个接收到任务的 NodeManager 发送程序启动脚本，这两个 NodeManager 分别启动 MapTask，MapTask 对数据分区排序。 </li>
<li>MrAppMaster 等待所有 MapTask 运行完毕后，向 RM 申请容器，运行 ReduceTask。 </li>
<li>ReduceTask 向 MapTask 获取相应分区的数据。</li>
<li>程序运行完毕后，MR 会向 RM 申请注销自己。</li>
</ul>
<h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><img src="/Hadoop%E6%90%AD%E5%BB%BA%E8%B0%83%E4%BC%98%E7%AC%94%E8%AE%B0/2022-01-16_16-03.png" alt="2022-01-16_16-03"></p>
<h3 id="Yarn核心参数配置"><a href="#Yarn核心参数配置" class="headerlink" title="Yarn核心参数配置"></a>Yarn核心参数配置</h3><blockquote>
<p>根据服务器的具体情况进行添加yarn-site.xml的配置</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 选择调度器，默认容量 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">description</span>&gt;</span>The class to use as the resource scheduler.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.scheduler.class<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity.CapacityScheduler<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ResourceManager处理调度器请求的线程数量,默认50；如果提交的任务数大于50，可以增加该值，但是不能超过3台 * 4线程 = 12线程（去除其他应用程序实际不能超过8） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">description</span>&gt;</span>Number of threads to handle scheduler interface.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.scheduler.client.thread-count<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>5<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 是否让yarn自动检测硬件进行配置，默认是false，如果该节点有很多其他应用程序，建议手动配置。如果该节点没有其他应用程序，可以采用自动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">description</span>&gt;</span>Enable auto-detection of node capabilities such as memory and CPU.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.resource.detect-hardware-capabilities<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 是否将虚拟核数当作CPU核数，默认是false，采用物理CPU核数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">description</span>&gt;</span>Flag to determine if logical processors(such as</span><br><span class="line">     hyperthreads) should be counted as cores. Only applicable on Linux</span><br><span class="line">     when yarn.nodemanager.resource.cpu-vcores is set to -1 and</span><br><span class="line">     yarn.nodemanager.resource.detect-hardware-capabilities is true.</span><br><span class="line">     <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.resource.count-logical-processors-as-cores<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 虚拟核数和物理核数乘数，默认是1.0 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">description</span>&gt;</span>Multiplier to determine how to convert phyiscal cores to</span><br><span class="line">     vcores. This value is used if yarn.nodemanager.resource.cpu-vcores</span><br><span class="line">     is set to -1(which implies auto-calculate vcores) and</span><br><span class="line">     yarn.nodemanager.resource.detect-hardware-capabilities is set to true. The number of vcores will be calculated as number of CPUs * multiplier.</span><br><span class="line">     <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.resource.pcores-vcores-multiplier<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- NodeManager使用内存数，默认8G，修改为4G内存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">description</span>&gt;</span>Amount of physical memory, in MB, that can be allocated </span><br><span class="line">     for containers. If set to -1 and</span><br><span class="line">     yarn.nodemanager.resource.detect-hardware-capabilities is true, it is</span><br><span class="line">     automatically calculated(in case of Windows and Linux).</span><br><span class="line">     In other cases, the default is 8192MB.</span><br><span class="line">     <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.resource.memory-mb<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>4096<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- nodemanager的CPU核数，不按照硬件环境自动设定时默认是8个，修改为4个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">description</span>&gt;</span>Number of vcores that can be allocated</span><br><span class="line">     for containers. This is used by the RM scheduler when allocating</span><br><span class="line">     resources for containers. This is not used to limit the number of</span><br><span class="line">     CPUs used by YARN containers. If it is set to -1 and</span><br><span class="line">     yarn.nodemanager.resource.detect-hardware-capabilities is true, it is</span><br><span class="line">     automatically determined from the hardware in case of Windows and Linux.</span><br><span class="line">     In other cases, number of vcores is 8 by default.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.resource.cpu-vcores<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 容器最小内存，默认1G --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">         The minimum allocation for every container request at the RM in MBs. Memory requests lower than this will be set to the value of this property. Additionally, a node manager that is configured to have less memory than this value will be shut down by the resource manager.</span><br><span class="line">     <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.minimum-allocation-mb<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>1024<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 容器最大内存，默认8G，修改为2G --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">         The maximum allocation for every container request at the RM in MBs. Memory requests higher than this will throw an InvalidResourceRequestException.</span><br><span class="line">     <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.maximum-allocation-mb<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>2048<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 容器最小CPU核数，默认1个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">         The minimum allocation for every container request at the RM in terms of virtual CPU cores. Requests lower than this will be set to the value of this property. Additionally, a node manager that is configured to have fewer virtual cores than this value will be shut down by the resource manager.</span><br><span class="line">     <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.minimum-allocation-vcores<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 容器最大CPU核数，默认4个，修改为2个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">         The maximum allocation for every container request at the RM in terms of virtual CPU cores. Requests higher than this will throw an InvalidResourceRequestException.</span><br><span class="line">     <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.maximum-allocation-vcores<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 虚拟内存检查，默认打开，修改为关闭 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">         Whether virtual memory limits will be enforced for containers.</span><br><span class="line">     <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.vmem-check-enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 虚拟内存和物理内存设置比例,默认2.1 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">         Ratio between virtual memory to physical memory when setting memory limits for containers. Container allocations are expressed in terms of physical memory, and virtual memory usage is allowed to exceed this allocation by this ratio.</span><br><span class="line">     <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.vmem-pmem-ratio<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 开启优先级，有5个等级 （）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.cluster.max-application-priority<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>5<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Yarn的调度器"><a href="#Yarn的调度器" class="headerlink" title="Yarn的调度器"></a>Yarn的调度器</h3><blockquote>
<p>在实际开发中一般不使用FIFO调度器。</p>
<p>容量调度器：中小型企业使用，对程序并发度要求不高。</p>
<p>公平调度器：中大型企业使用，对程序并发度要求较高。</p>
</blockquote>
<h4 id="容量调度器"><a href="#容量调度器" class="headerlink" title="容量调度器"></a>容量调度器</h4><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol>
<li>多队列：每个队列可配置一定的资源量，每个队列采用FIFO调度策略。</li>
<li>容量保证：管理员可为每个队列设置资源最低保证和资源使用上限 </li>
<li>灵活性：如果一个队列中的资源有剩余，可以暂时共享给那些需要资源的队列，而一旦该队列有新的应用 程序提交，则其他队列借调的资源会归还给该队列。 </li>
<li>多租户： 支持多用户共享集群和多应用程序同时运行。 为了防止同一个用户的作业独占队列中的资源，该调度器会对同一用户提交的作业所占资源量进行限定</li>
</ol>
<h5 id="资源分配算法"><a href="#资源分配算法" class="headerlink" title="资源分配算法"></a>资源分配算法</h5><ol>
<li><p>队列资源分配</p>
<p>使用深度优先算法，优先 选择资源占用率最低的队列分配资源。</p>
</li>
<li><p>作业资源分配</p>
<p>默认按照提交作业的优先级和提交时间 顺序分配资源。(FIFO)</p>
</li>
<li><p>容器资源分配</p>
<p>按照容器的优先级分配资源； 如果优先级相同，按照数据本地性原则：</p>
<ol>
<li>任务和数据在同一节点</li>
<li>任务和数据在同一机架 </li>
<li>任务和数据不在同一节点也不在同一机架</li>
</ol>
</li>
</ol>
<h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><h6 id="capacity-scheduler-xml"><a href="#capacity-scheduler-xml" class="headerlink" title="capacity-scheduler.xml"></a>capacity-scheduler.xml</h6><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--（1）修改默认属性配置：--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定多队列，增加hive队列 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.capacity.root.queues<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>default,hive<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">      The queues at the this level (root is the root queue).</span><br><span class="line">    <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 降低default队列资源额定容量为40%，默认100% --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.capacity.root.default.capacity<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>40<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 降低default队列资源最大容量为60%，默认100% --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.capacity.root.default.maximum-capacity<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>60<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--（2）为新加队列添加必要属性：--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定hive队列的资源额定容量 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.capacity.root.hive.capacity<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>60<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用户最多可以使用队列多少资源，1表示 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.capacity.root.hive.user-limit-factor<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 指定hive队列的资源最大容量 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.capacity.root.hive.maximum-capacity<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>80<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 启动hive队列 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.capacity.root.hive.state<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>RUNNING<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 哪些用户有权向队列提交作业 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.capacity.root.hive.acl_submit_applications<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>*<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 哪些用户有权操作队列，管理员权限（查看/杀死） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.capacity.root.hive.acl_administer_queue<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>*<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 哪些用户有权配置提交任务优先级 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.capacity.root.hive.acl_application_max_priority<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>*<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 任务的超时时间设置：yarn application -appId appId -updateLifetime Timeout</span></span><br><span class="line"><span class="comment">参考资料：https://blog.cloudera.com/enforcing-application-lifetime-slas-yarn/ --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 如果application指定了超时时间，则提交到该队列的application能够指定的最大超时时间不能超过该值。 </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.capacity.root.hive.maximum-application-lifetime<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 如果application没指定超时时间，则用default-application-lifetime作为默认值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.capacity.root.hive.default-application-lifetime<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="公平调度器"><a href="#公平调度器" class="headerlink" title="公平调度器"></a>公平调度器</h4><blockquote>
<p>在Apache的hadoop中默认的是容量调度器，如果需要修改为公平调度器，需要修改yarn-site.xml文件指定容器类型。</p>
</blockquote>
<h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><ol>
<li>多队列：每个队列可配置一定的资源量，每个队列采用FIFO调度策略。</li>
<li>容量保证：管理员可为每个队列设置资源最低保证和资源使用上限 </li>
<li>灵活性：如果一个队列中的资源有剩余，可以暂时共享给那些需要资源的队列，而一旦该队列有新的应用 程序提交，则其他队列借调的资源会归还给该队列。 </li>
<li>多租户： 支持多用户共享集群和多应用程序同时运行。 为了防止同一个用户的作业独占队列中的资源，该调度器会对同一用户提交的作业所占资源量进行限定</li>
</ol>
<h5 id="资源分配算法-1"><a href="#资源分配算法-1" class="headerlink" title="资源分配算法"></a>资源分配算法</h5><blockquote>
<p>缺额：作业获取资源的过程并不是瞬间得到，而是在一段时间内不断获取。某个任务理想中得到的资源与现有的资源的差值就是缺额</p>
<p>公平调度器设计目标是：在时间尺度上，所有作业获得公平的资源。某一 时刻一个作业应获资源和实际获取资源的差距叫“缺额” ，调度器会优先为缺额大的作业分配资。(Fair)</p>
</blockquote>
<p> Fair 策略（默认）是一种基于最大最小公平算法实现的资源多路复用方式，默认情况下，每个队列内部采用该方式分配资 源。这意味着，如果一个队列中有两个应用程序同时运行，则每个应用程序可得到1&#x2F;2的资源；如果三个应用程序同时运行，则 每个应用程序可得到1&#x2F;3的资源。 分别计算比较对象的（实际最小资源份额、是 否饥饿、资源分配比、资源使用权重比） 具体资源分配流程和容量调度器一致；</p>
<ol>
<li>队列资源分配</li>
<li>作业资源分配</li>
<li>容器资源分配</li>
</ol>
<p>以上三步，每一步都是按照公平策略分配资源</p>
<p>➢ 实际最小资源份额：mindshare &#x3D; Min（资源需求量，配置的最小资源） </p>
<p>➢ 是否饥饿：isNeedy &#x3D; 资源使用量 &lt; mindshare（实际最小资源份额） </p>
<p>➢ 资源分配比：minShareRatio &#x3D; 资源使用量 &#x2F; Max（mindshare, 1） </p>
<p>➢ 资源使用权重比：useToWeightRatio &#x3D; 资源使用量 &#x2F; 权重</p>
<h5 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h5><h6 id="yarn-site-xml-1"><a href="#yarn-site-xml-1" class="headerlink" title="yarn-site.xml"></a>yarn-site.xml</h6><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.scheduler.class<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.yarn.server.resourcemanager.scheduler.fair.FairS</span><br><span class="line">cheduler<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">description</span>&gt;</span>配置使用公平调度器<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.fair.allocation.file<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/module/hadoop-3.3.1/etc/hadoop/fair-scheduler.xml<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">description</span>&gt;</span>指明公平调度器队列分配配置文件<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.fair.preemption<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">description</span>&gt;</span>禁止队列间资源抢占<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="fair-scheduler-xml"><a href="#fair-scheduler-xml" class="headerlink" title="fair-scheduler.xml"></a>fair-scheduler.xml</h6><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">allocations</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 单个队列中 Application Master 占用资源的最大比例,取值 0-1 ，企业一般配置 0.1 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">queueMaxAMShareDefault</span>&gt;</span>0.5<span class="tag">&lt;/<span class="name">queueMaxAMShareDefault</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 单个队列最大资源的默认值 test luo default --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">queueMaxResourcesDefault</span>&gt;</span>4096mb,4vcores<span class="tag">&lt;/<span class="name">queueMaxResourcesDefault</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 增加一个队列 test --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">queue</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 队列最小资源 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">minResources</span>&gt;</span>2048mb,2vcores<span class="tag">&lt;/<span class="name">minResources</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 队列最大资源 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">maxResources</span>&gt;</span>4096mb,4vcores<span class="tag">&lt;/<span class="name">maxResources</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 队列中最多同时运行的应用数，默认 50，根据线程数配置 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">maxRunningApps</span>&gt;</span>4<span class="tag">&lt;/<span class="name">maxRunningApps</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 队列中 Application Master 占用资源的最大比例 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">maxAMShare</span>&gt;</span>0.5<span class="tag">&lt;/<span class="name">maxAMShare</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 该队列资源权重,默认值为 1.0 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">weight</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">weight</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 队列内部的资源分配策略 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">schedulingPolicy</span>&gt;</span>fair<span class="tag">&lt;/<span class="name">schedulingPolicy</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">queue</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 增加一个队列 luo --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">queue</span> <span class="attr">name</span>=<span class="string">&quot;luo&quot;</span> <span class="attr">type</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 队列最小资源 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">minResources</span>&gt;</span>2048mb,2vcores<span class="tag">&lt;/<span class="name">minResources</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 队列最大资源 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">maxResources</span>&gt;</span>4096mb,4vcores<span class="tag">&lt;/<span class="name">maxResources</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 队列中最多同时运行的应用数，默认 50，根据线程数配置 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">maxRunningApps</span>&gt;</span>4<span class="tag">&lt;/<span class="name">maxRunningApps</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 队列中 Application Master 占用资源的最大比例 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">maxAMShare</span>&gt;</span>0.5<span class="tag">&lt;/<span class="name">maxAMShare</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 该队列资源权重,默认值为 1.0 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">weight</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">weight</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 队列内部的资源分配策略 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">schedulingPolicy</span>&gt;</span>fair<span class="tag">&lt;/<span class="name">schedulingPolicy</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">queue</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 任务队列分配策略,可配置多层规则,从第一个规则开始匹配,直到匹配成功 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">queuePlacementPolicy</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 提交任务时指定队列,如未指定提交队列,则继续匹配下一个规则; false 表示：如果指</span></span><br><span class="line"><span class="comment">        定队列不存在,不允许自动创建--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">rule</span> <span class="attr">name</span>=<span class="string">&quot;specified&quot;</span> <span class="attr">create</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 提交到 root.group.username 队列,若 root.group 不存在,不允许自动创建；若</span></span><br><span class="line"><span class="comment">        root.group.user 不存在,允许自动创建 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">rule</span> <span class="attr">name</span>=<span class="string">&quot;nestedUserQueue&quot;</span> <span class="attr">create</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">rule</span> <span class="attr">name</span>=<span class="string">&quot;primaryGroup&quot;</span> <span class="attr">create</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 最后一个规则必须为 reject 或者 default。Reject 表示拒绝创建提交失败，</span></span><br><span class="line"><span class="comment">        default 表示把任务提交到 default 队列 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">rule</span> <span class="attr">name</span>=<span class="string">&quot;reject&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">queuePlacementPolicy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">allocations</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Tool接口的编写"><a href="#Tool接口的编写" class="headerlink" title="Tool接口的编写"></a>Tool接口的编写</h3><blockquote>
<p>为了方便对程序的使用编写接口</p>
<p>以WordCount为例</p>
</blockquote>
<h4 id="WordCount"><a href="#WordCount" class="headerlink" title="WordCount"></a>WordCount</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.luo.TOO接口案例;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.Tool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCount</span> <span class="keyword">implements</span> <span class="title class_">Tool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Configuration conf;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">run</span><span class="params">(String[] strings)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Job</span> <span class="variable">job</span> <span class="operator">=</span> Job.getInstance(conf);</span><br><span class="line"></span><br><span class="line">        job.setJarByClass(WordCountDriver.class);</span><br><span class="line">        job.setMapperClass(WCMapper.class);</span><br><span class="line">        job.setReducerClass(WCReducer.class);</span><br><span class="line"></span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(IntWritable.class);</span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line"></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> <span class="title class_">Path</span>(strings[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> <span class="title class_">Path</span>(strings[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> job.waitForCompletion(<span class="literal">true</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConf</span><span class="params">(Configuration configuration)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.conf = configuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Configuration <span class="title function_">getConf</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> conf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WCMapper</span> <span class="keyword">extends</span> <span class="title class_">Mapper</span>&lt;LongWritable, Text, Text, IntWritable&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Text</span> <span class="variable">outK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>();</span><br><span class="line">        <span class="keyword">private</span> <span class="type">IntWritable</span> <span class="variable">outV</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntWritable</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">map</span><span class="params">(LongWritable key, Text value, Mapper&lt;LongWritable, Text, Text, IntWritable&gt;.Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> value.toString();</span><br><span class="line">            <span class="keyword">for</span> (String s : line.split(<span class="string">&quot; &quot;</span>)) &#123;</span><br><span class="line">                outK.set(s);</span><br><span class="line">                context.write(outK, outV);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WCReducer</span> <span class="keyword">extends</span> <span class="title class_">Reducer</span>&lt;Text, IntWritable, Text, IntWritable&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">IntWritable</span> <span class="variable">outV</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntWritable</span>();</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Reducer&lt;Text, IntWritable, Text, IntWritable&gt;.Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (IntWritable value : values) &#123;</span><br><span class="line">                sum += value.get();</span><br><span class="line">            &#125;</span><br><span class="line">            outV.set(sum);</span><br><span class="line">            context.write(key, outV);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="WordCountDriver"><a href="#WordCountDriver" class="headerlink" title="WordCountDriver"></a>WordCountDriver</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.luo.TOO接口案例;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.Tool;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.ToolRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCountDriver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Tool tool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (args[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;wordcount&quot;</span>:</span><br><span class="line">                tool = <span class="keyword">new</span> <span class="title class_">WordCount</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;非法接口：&quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">run</span> <span class="operator">=</span> ToolRunner.run(conf, tool, Arrays.copyOfRange(args, args.length - <span class="number">2</span>, args.length));</span><br><span class="line">        System.exit(run);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生产调优"><a href="#生产调优" class="headerlink" title="生产调优"></a>生产调优</h2><h3 id="HDFS—核心参数"><a href="#HDFS—核心参数" class="headerlink" title="HDFS—核心参数"></a>HDFS—核心参数</h3><h4 id="NameNode、DataNode内存生产配置"><a href="#NameNode、DataNode内存生产配置" class="headerlink" title="NameNode、DataNode内存生产配置"></a>NameNode、DataNode内存生产配置</h4><h5 id="NameNode内存计算"><a href="#NameNode内存计算" class="headerlink" title="NameNode内存计算"></a>NameNode内存计算</h5><p>每个文件块大概占用 150byte。一台服务器 128G 内存为例，能存储128 * 1024 * 1024 * 1024 &#x2F; 150Byte ≈ 9.1 亿</p>
<h5 id="配置-NameNode、DataNode内存"><a href="#配置-NameNode、DataNode内存" class="headerlink" title="配置 NameNode、DataNode内存"></a>配置 NameNode、DataNode内存</h5><blockquote>
<p>在Hadoop3.x 系列中默认NameNode是根据服务器动态分配的。</p>
<p>配置文件：hadoop-env.sh</p>
</blockquote>
<p>配置策略：</p>
<ol>
<li>NameNode：最小值为1G，每增加1000000个block，增加1G内存</li>
<li>DataNode：在一个DataNode上的副本总数低于4000000，调为4G。超过4000000，每增加1000000，增加1G</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HDFS_NAMENODE_OPTS=&quot;-Dhadoop.security.logger=INFO,RFAS -Xmx1024m&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">当前机器为学习机器，所以调为1G。</span></span><br><span class="line">export HDFS_DATANODE_OPTS=&quot;-Dhadoop.security.logger=ERROR,RFAS -Xmx1024m&quot;</span><br></pre></td></tr></table></figure>

<h4 id="NameNode-心跳并发配置"><a href="#NameNode-心跳并发配置" class="headerlink" title="NameNode 心跳并发配置"></a>NameNode 心跳并发配置</h4><blockquote>
<p>NameNode 有一个工作线程池，用来处理不同 DataNode 的并发心跳以及客户端并发 的元数据操作。 对于大集群或者有大量客户端的集群来说，通常需要增大该参数。默认值是 10。</p>
<p>配置文件：hdfs-site.xml</p>
</blockquote>
<p>企业经验：dfs.namenode.handler.count&#x3D;20 × log以e为底的集群数量，比如集群规模（DataNode 台数）为 3 台时，此参数设置为 21。<br>使用Python计算：print(int(20*math.log(3)))<br>$$<br>dfs.namenode.handler.count&#x3D;20 × log_{e}^{n}<br>$$</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.handler.count<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>21<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="开启回收站配置"><a href="#开启回收站配置" class="headerlink" title="开启回收站配置"></a>开启回收站配置</h4><blockquote>
<p>开启回收站功能，可以将删除的文件在不超时的情况下，恢复原数据，起到防止误删除、 备份等作用。</p>
<p>单位为分钟。0 表示禁用回收站；其他值表示设置文件的存活时间。</p>
<p>配置文件 ：core-site.xml</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.trash.interval<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="HDFS—多目录"><a href="#HDFS—多目录" class="headerlink" title="HDFS—多目录"></a>HDFS—多目录</h3><h4 id="NameNode-多目录配置"><a href="#NameNode-多目录配置" class="headerlink" title="NameNode 多目录配置"></a>NameNode 多目录配置</h4><blockquote>
<p>NameNode 的本地目录可以配置成多个，且每个目录存放内容相同，增加了可靠性。</p>
<p>在 hdfs-site.xml 文件中添加如下内容</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>file://$&#123;hadoop.tmp.dir&#125;/dfs/name1,file://$&#123;hadoop.tmp.dir&#125;/dfs/name2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>重启集群</p>
<p>停止集群，删除三台节点的 data 和 logs 中所有数据。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[luo@hadoop102 hadoop-3.3.1]$ rm -rf data/ logs/</span><br><span class="line">[luo@hadoop103 hadoop-3.3.1]$ rm -rf data/ logs/</span><br><span class="line">[luo@hadoop104 hadoop-3.3.1]$ rm -rf data/ logs/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>格式化集群并启动。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[luo@hadoop102 hadoop-3.3.1]$ bin/hdfs namenode -format</span><br><span class="line">[luo@hadoop102 hadoop-3.3.1]$ sbin/start-dfs.sh</span><br></pre></td></tr></table></figure>

<h4 id="DataNode-多目录配置"><a href="#DataNode-多目录配置" class="headerlink" title="DataNode 多目录配置"></a>DataNode 多目录配置</h4><blockquote>
<p>DataNode 可以配置成多个目录，每个目录存储的数据不一样（数据不是副本）</p>
<p>在 hdfs-site.xml 文件中添加如下内容</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>file://$&#123;hadoop.tmp.dir&#125;/dfs/data1,file://$&#123;hadoop.tmp.dir&#125;/dfs/data2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="集群数据均衡之磁盘间数据均衡"><a href="#集群数据均衡之磁盘间数据均衡" class="headerlink" title="集群数据均衡之磁盘间数据均衡"></a>集群数据均衡之磁盘间数据均衡</h4><blockquote>
<p>生产环境，由于硬盘空间不足，往往需要增加一块硬盘。刚加载的硬盘没有数据时，可 以执行磁盘数据均衡命令。（Hadoop3.x 新特性）</p>
</blockquote>
<ol>
<li>生成均衡计划（我们只有一块磁盘，不会生成计划）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs diskbalancer -plan hadoop103 </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>执行均衡计划</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs diskbalancer -execute hadoop103.plan.json </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>查看当前均衡任务的执行情况</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs diskbalancer -query hadoop103 </span><br></pre></td></tr></table></figure>

<ol start="4">
<li>取消均衡任务</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs diskbalancer -cancel hadoop103.plan.json</span><br></pre></td></tr></table></figure>

<h3 id="HDFS—集群扩容及缩容"><a href="#HDFS—集群扩容及缩容" class="headerlink" title="HDFS—集群扩容及缩容"></a>HDFS—集群扩容及缩容</h3><h4 id="添加黑白名单"><a href="#添加黑白名单" class="headerlink" title="添加黑白名单"></a>添加黑白名单</h4><blockquote>
<p>白名单：表示在白名单的主机 IP 地址可以用来存储数据。 </p>
<p>企业中：配置白名单，可以尽量防止黑客恶意访问攻击。</p>
<p>黑名单：表示在黑名单的主机 IP 地址不可以用来存储数据。</p>
<p> 企业中：配置黑名单，用来退役服务器。</p>
<p>配置文件： hdfs-site.xml</p>
</blockquote>
<ol>
<li><p>创建黑白名单</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[luo@hadoop102 hadoop]$ vim whitelist</span><br><span class="line">[luo@hadoop102 hadoop]$ vim blicklist</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 hdfs-site.xml 配置文件中增加 dfs.hosts 配置参数</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 白名单 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.hosts<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/module/hadoop-3.3.1/etc/hadoop/whitelist<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 黑名单 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.hosts.exclude<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/module/hadoop-3.3.1/etc/hadoop/blacklist<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>分发配置文件 whitelist，hdfs-site.xm</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[luo@hadoop104 hadoop]$ xsync hdfs-site.xml whitelist</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一次添加白名单必须重启集群，不是第一次，只需要刷新 NameNode 节点即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[luo@hadoop102 hadoop-3.3.1]$ myhadoop.sh stop</span><br><span class="line">[luo@hadoop102 hadoop-3.3.1]$ myhadoop.sh start</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">刷新 NameNode命令</span></span><br><span class="line">[luo@hadoop102 hadoop-3.3.1]$ hdfs dfsadmin -refreshNodesRefresh nodes successful</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="服役新服务器"><a href="#服役新服务器" class="headerlink" title="服役新服务器"></a>服役新服务器</h4><blockquote>
<p>随着公司业务的增长，数据量越来越大，原有的数据节点的容量已经不能满足存储数据 的需求，需要在原有集群基础上动态添加新的数据节点。</p>
</blockquote>
<ol>
<li><p>配置 hadoop102 和 hadoop103 到 hadoop105 的 ssh 无密登录(NameNode和Yarn所在节点）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">102</span></span><br><span class="line">[luo@hadoop102 .ssh]$ ssh-copy-id hadoop105</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">103</span></span><br><span class="line">[luo@hadoop103 .ssh]$ ssh-copy-id hadoop105</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加workers</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop102</span><br><span class="line">hadoop103</span><br><span class="line">hadoop104</span><br><span class="line">hadoop105</span><br></pre></td></tr></table></figure>
</li>
<li><p>分发 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">只分发配置文件</span></span><br><span class="line">[luo@hadoop102 hadoop]$ xsync hadoop</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接启动 新节点，即可关联到集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[luo@hadoop105 hadoop-3.3.1]$ hdfs --daemon start datanode</span><br><span class="line">[luo@hadoop105 hadoop-3.3.1]$ yarn --daemon start nodemanager</span><br></pre></td></tr></table></figure>
</li>
<li><p>刷新 NameNode</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[luo@hadoop102 hadoop-3.3.1]$ hdfs dfsadmin -refreshNodesRefresh nodes successful</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="服务器间数据均衡"><a href="#服务器间数据均衡" class="headerlink" title="服务器间数据均衡"></a>服务器间数据均衡</h4><blockquote>
<ol>
<li>在企业开发中，如果经常在 hadoop102 和 hadoop104 上提交任务，且副本数为 2，由于 数据本地性原则，就会导致 hadoop102 和 hadoop104 数据过多，hadoop103 存储的数据量小。</li>
<li>另一种情况，就是新服役的服务器数据量比较少，需要执行集群均衡命令。</li>
<li>&#x3D;&#x3D;注意：由于 HDFS 需要启动单独的 Rebalance Server 来执行 Rebalance 操作，所以尽量 不要在 NameNode 上执行 start-balancer.sh，而是找一台比较空闲的机器。&#x3D;&#x3D;</li>
</ol>
</blockquote>
<ol>
<li><p>开启数据均衡命令</p>
<blockquote>
<p>对于参数 10，代表的是集群中各个节点的磁盘空间利用率相差不超过 10%，可根据实 际情况进行调整。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[luo@hadoop102 hadoop-3.3.1]$ sbin/start-balancer.sh -threshold 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止数据均衡命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[luo@hadoop102 hadoop-3.3.1]$ sbin/stop-balancer.sh</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="黑名单退役服务器"><a href="#黑名单退役服务器" class="headerlink" title="黑名单退役服务器"></a>黑名单退役服务器</h4><ol>
<li><p>编辑&#x2F;opt&#x2F;module&#x2F;hadoop-3.3.1&#x2F;etc&#x2F;hadoop 目录下的 blacklist 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加加入黑名单的服务器</span></span><br><span class="line">hadoop105</span><br></pre></td></tr></table></figure>
</li>
<li><p>分发配置文件 blacklist</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xsync hdfs-site.xml </span><br></pre></td></tr></table></figure>
</li>
<li><p>刷新 NameNode 节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs dfsadmin -refreshNodesRefresh nodes successful</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="HDFS—存储优化"><a href="#HDFS—存储优化" class="headerlink" title="HDFS—存储优化"></a>HDFS—存储优化</h3><h4 id="纠删码"><a href="#纠删码" class="headerlink" title="纠删码"></a>纠删码</h4><blockquote>
<p>HDFS 默认情况下，一个文件有 3 个副本，这样提高了数据的可靠性，但也带来了 2 倍 的冗余开销。Hadoop3.x 引入了纠删码，采用计算的方式，可以节省约 50％左右的存储空间。</p>
</blockquote>
<ol>
<li><p>纠删码操作相关的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[luo@hadoop102 hadoop-3.3.1]$ hdfs ec</span><br><span class="line">Usage: bin/hdfs ec [COMMAND]</span><br><span class="line"> [-listPolicies]</span><br><span class="line"> [-addPolicies -policyFile &lt;file&gt;]</span><br><span class="line"> [-getPolicy -path &lt;path&gt;]</span><br><span class="line"> [-removePolicy -policy &lt;policy&gt;]</span><br><span class="line"> [-setPolicy -path &lt;path&gt; [-policy &lt;policy&gt;] [-replicate]]</span><br><span class="line"> [-unsetPolicy -path &lt;path&gt;]</span><br><span class="line"> [-listCodecs]</span><br><span class="line"> [-enablePolicy -policy &lt;policy&gt;]</span><br><span class="line"> [-disablePolicy -policy &lt;policy&gt;]</span><br><span class="line"> [-help &lt;command-name&gt;].</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看当前支持的纠删码策略</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[luo@hadoop102 hadoop-3.3.1] hdfs ec -listPolicies</span><br><span class="line">Erasure Coding Policies:</span><br><span class="line">ErasureCodingPolicy=[Name=RS-10-4-1024k, Schema=[ECSchema=[Codec=rs, </span><br><span class="line">numDataUnits=10, numParityUnits=4]], CellSize=1048576, Id=5], </span><br><span class="line">State=DISABLED</span><br><span class="line">ErasureCodingPolicy=[Name=RS-3-2-1024k, Schema=[ECSchema=[Codec=rs, </span><br><span class="line">numDataUnits=3, numParityUnits=2]], CellSize=1048576, Id=2], </span><br><span class="line">State=DISABLED</span><br><span class="line">ErasureCodingPolicy=[Name=RS-6-3-1024k, Schema=[ECSchema=[Codec=rs, </span><br><span class="line">numDataUnits=6, numParityUnits=3]], CellSize=1048576, Id=1], </span><br><span class="line">State=ENABLED</span><br><span class="line">ErasureCodingPolicy=[Name=RS-LEGACY-6-3-1024k, </span><br><span class="line">Schema=[ECSchema=[Codec=rs-legacy, numDataUnits=6, numParityUnits=3]], </span><br><span class="line">CellSize=1048576, Id=3], State=DISABLED</span><br><span class="line">ErasureCodingPolicy=[Name=XOR-2-1-1024k, Schema=[ECSchema=[Codec=xor, </span><br><span class="line">numDataUnits=2, numParityUnits=1]], CellSize=1048576, Id=4], </span><br><span class="line">State=DISABLED</span><br></pre></td></tr></table></figure>
</li>
<li><p>纠删码策略解释:</p>
<ol>
<li>RS-3-2-1024k：使用 RS 编码，每 3 个数据单元，生成 2 个校验单元，共 5 个单元，也 就是说：这 5 个单元中，只要有任意的 3 个单元存在（不管是数据单元还是校验单元，只要总数&#x3D;3），就可以得到原始数据。每个单元的大小是 1024k&#x3D;1024*1024&#x3D;1048576。</li>
<li>RS-10-4-1024k：使用 RS 编码，每 10 个数据单元（cell），生成 4 个校验单元，共 14 个单元，也就是说：这 14 个单元中，只要有任意的 10 个单元存在（不管是数据单元还是校 验单元，只要总数&#x3D;10），就可以得到原始数据。每个单元的大小是 1024k&#x3D;1024*1024&#x3D;1048576。</li>
<li>RS-6-3-1024k：使用 RS 编码，每 6 个数据单元，生成 3 个校验单元，共 9 个单元，也 就是说：这 9 个单元中，只要有任意的 6 个单元存在（不管是数据单元还是校验单元，只要 总数&#x3D;6），就可以得到原始数据。每个单元的大小是 1024k&#x3D;1024*1024&#x3D;1048576。</li>
<li>RS-LEGACY-6-3-1024k：策略和上面的 RS-6-3-1024k 一样，只是编码的算法用的是 rs-legacy</li>
<li>XOR-2-1-1024k：使用 XOR 编码（速度比 RS 编码快），每 2 个数据单元，生成 1 个校 验单元，共 3 个单元，也就是说：这 3 个单元中，只要有任意的 2 个单元存在（不管是数据 单元还是校验单元，只要总数&#x3D; 2），就可以得到原始数据。每个单元的大小是 1024k&#x3D;1024*1024&#x3D;1048576。</li>
</ol>
</li>
<li><p>具体步骤</p>
<ol>
<li><p>开启对 RS-3-2-1024k 策略的支持</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[luo@hadoop102 hadoop-3.3.1]$ hdfs ec -enablePolicy -policy RS-3-2-1024k</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 HDFS 创建目录，并设置 RS-3-2-1024k 策略</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[luo@hadoop102 hadoop-3.3.1]$ hdfs dfs -mkdir /input</span><br><span class="line">[luo@hadoop202 hadoop-3.3.1]$ hdfs ec -setPolicy -path /input -policy RS-3-2-1024k</span><br></pre></td></tr></table></figure>
</li>
<li><p>并查看文件编码后的存储情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[luo@hadoop102 hadoop-3.3.1]$ hdfs dfs -put web.log /input</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4 id="异构存储（冷热数据分离）"><a href="#异构存储（冷热数据分离）" class="headerlink" title="异构存储（冷热数据分离）"></a>异构存储（冷热数据分离）</h4><blockquote>
<p>异构存储主要解决，不同的数据，存储在不同类型的硬盘中，达到最佳性能的问题。</p>
</blockquote>
<h3 id="HDFS—故障排除"><a href="#HDFS—故障排除" class="headerlink" title="HDFS—故障排除"></a>HDFS—故障排除</h3><h4 id="NameNode-故障处理"><a href="#NameNode-故障处理" class="headerlink" title="NameNode 故障处理"></a>NameNode 故障处理</h4><blockquote>
<p>NameNode 进程挂了并且存储的数据也丢失了，如何恢复 NameNode</p>
</blockquote>
<ol>
<li><p>拷贝 SecondaryNameNode 中数据到原 NameNode 存储数据目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop102 dfs]$ scp -r atguigu@hadoop104:/opt/module/hadoop-3.1.3/data/dfs/namesecondary/* ./name/</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新启动 NameNode</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop102 hadoop-3.1.3]$ hdfs --daemon start namenode</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="集群安全模式-amp-磁盘修复"><a href="#集群安全模式-amp-磁盘修复" class="headerlink" title="集群安全模式&amp;磁盘修复"></a>集群安全模式&amp;磁盘修复</h4><ol>
<li><p>退出安全模式条件</p>
<ul>
<li>dfs.namenode.safemode.min.datanodes:最小可用 datanode 数量，默认 0 </li>
<li>dfs.namenode.safemode.threshold-pct:副本数达到最小要求的 block 占系统总 block 数的 百分比，默认 0.999f。（只允许丢一个块）</li>
<li>dfs.namenode.safemode.extension:稳定时间，默认值 30000 毫秒，即 30 秒</li>
</ul>
</li>
<li><p>基本语法</p>
<blockquote>
<p>集群处于安全模式，不能执行重要操作（写操作）。集群启动完成后，自动退出安全模 式。</p>
</blockquote>
<ul>
<li>bin&#x2F;hdfs dfsadmin -safemode get （功能描述：查看安全模式状态）</li>
<li>bin&#x2F;hdfs dfsadmin -safemode enter （功能描述：进入安全模式状态）</li>
<li>bin&#x2F;hdfs dfsadmin -safemode leave（功能描述：离开安全模式状态）</li>
<li>bin&#x2F;hdfs dfsadmin -safemode wait （功能描述：等待安全模式状态）：在等待安全模式下提交任务，任务会在集群离开安全模式后自动运行提交的任务</li>
</ul>
</li>
<li><p>磁盘修复</p>
<blockquote>
<p>文件块及其副本全部丢失，集群进入锁死状态</p>
</blockquote>
<p>离开安全模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop102 subdir0]$ hdfs dfsadmin -safemode get Safe mode is ON</span><br><span class="line">[atguigu@hadoop102 subdir0]$ hdfs dfsadmin -safemode leave Safe mode is OFF</span><br></pre></td></tr></table></figure>

<p>将元数据删除</p>
</li>
</ol>
<h4 id="小文件归档"><a href="#小文件归档" class="headerlink" title="小文件归档"></a>小文件归档</h4><blockquote>
<p>HDFS 存档文件或 HAR 文件，是一个更高效的文件存档工具，它将文件存入 HDFS 块， 在减少 NameNode 内存使用的同时，允许对文件进行透明的访问。具体说来，HDFS 存档文 件对内还是一个一个独立文件，对 NameNode 而言却是一个整体，减少了 NameNode 的内 存。</p>
</blockquote>
<ol>
<li><p>需要启动 YARN 进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop102 hadoop-3.1.3]$ start-yarn.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>归档文件</p>
<blockquote>
<p>把&#x2F;input 目录里面的所有文件归档成一个叫 input.har 的归档文件，并把归档后文件存储 到&#x2F;output 路径下。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop102 hadoop-3.1.3]$ hadoop archive -archiveName input.har -p /input /output</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看归档</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop102 hadoop-3.1.3]$ hadoop fs -ls /output/input.har</span><br><span class="line">[atguigu@hadoop102 hadoop-3.1.3]$ hadoop fs -ls har:///output/input.har</span><br></pre></td></tr></table></figure>
</li>
<li><p>解归档文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop102 hadoop-3.1.3]$ hadoop fs -cp har:///output/input.har/* /</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="HDFS—集群迁移"><a href="#HDFS—集群迁移" class="headerlink" title="HDFS—集群迁移"></a>HDFS—集群迁移</h3><h4 id="Apache-和-Apache-集群间数据拷贝"><a href="#Apache-和-Apache-集群间数据拷贝" class="headerlink" title="Apache 和 Apache 集群间数据拷贝"></a>Apache 和 Apache 集群间数据拷贝</h4><p>采用 distcp 命令实现两个 Hadoop 集群之间的递归数据复制</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop102 hadoop-3.1.3]$ bin/hadoop distcp hdfs://hadoop102:8020/user/atguigu/hello.txt hdfs://hadoop105:8020/user/atguigu/hello.txt</span><br></pre></td></tr></table></figure>

<h4 id="Apache-和-CDH-集群间数据拷贝"><a href="#Apache-和-CDH-集群间数据拷贝" class="headerlink" title="Apache 和 CDH 集群间数据拷贝"></a>Apache 和 CDH 集群间数据拷贝</h4><blockquote>
<p>不常见</p>
</blockquote>
<h3 id="MapReduce-生产经验"><a href="#MapReduce-生产经验" class="headerlink" title="MapReduce 生产经验"></a>MapReduce 生产经验</h3><h4 id="MapReduce-跑的慢的原因"><a href="#MapReduce-跑的慢的原因" class="headerlink" title="MapReduce 跑的慢的原因"></a>MapReduce 跑的慢的原因</h4><blockquote>
<p>MapReduce 程序效率的瓶颈在于两点：</p>
</blockquote>
<ol>
<li><p>计算机性能</p>
<p>CPU、内存、磁盘、网络</p>
</li>
<li><p>I&#x2F;O 操作优化</p>
<ul>
<li>数据倾斜</li>
<li>Map 运行时间太长，导致 Reduce 等待过久</li>
<li>小文件过多</li>
</ul>
</li>
</ol>
<h4 id="MapReduce-常用调优参数"><a href="#MapReduce-常用调优参数" class="headerlink" title="MapReduce 常用调优参数"></a>MapReduce 常用调优参数</h4><h5 id="Map——-gt-Shuffle"><a href="#Map——-gt-Shuffle" class="headerlink" title="Map——&gt;Shuffle"></a>Map——&gt;Shuffle</h5><p><img src="/Hadoop%E6%90%AD%E5%BB%BA%E8%B0%83%E4%BC%98%E7%AC%94%E8%AE%B0/2022-01-24_15-36.png"></p>
<h6 id="自定义分区，减少数据倾斜"><a href="#自定义分区，减少数据倾斜" class="headerlink" title="自定义分区，减少数据倾斜"></a>自定义分区，减少数据倾斜</h6><p>   定义类，继承Partitioner接口，重写getPartition方法</p>
<h6 id="减少溢写的次数"><a href="#减少溢写的次数" class="headerlink" title="减少溢写的次数"></a>减少溢写的次数</h6><ul>
<li>mapreduce.task.io.sort.mb Shuffle的环形缓冲区大小，默认100m，可以提高到200m </li>
<li>mapreduce.map.sort.spill.percent 环形缓冲区溢出的阈值，默认80% ，可以提高的90%</li>
</ul>
<h6 id="增加每次Merge合并次数"><a href="#增加每次Merge合并次数" class="headerlink" title="增加每次Merge合并次数"></a>增加每次Merge合并次数</h6><p>   mapreduce.task.io.sort.factor默认10，可以提高到20</p>
<h6 id="采用Combiner"><a href="#采用Combiner" class="headerlink" title="采用Combiner"></a>采用Combiner</h6><blockquote>
<p>在不影响业务结果的前提条件下可以提前</p>
</blockquote>
<p>   job.setCombinerClass(xxxReducer.class)</p>
<h6 id="采用Snappy或者LZO压缩"><a href="#采用Snappy或者LZO压缩" class="headerlink" title="采用Snappy或者LZO压缩"></a>采用Snappy或者LZO压缩</h6><blockquote>
<p>减少磁盘IO</p>
</blockquote>
<ul>
<li>conf.setBoolean(“mapreduce.map.output.compress”, true); </li>
<li>conf.setClass(“mapreduce.map.output.compress.codec”,  SnappyCodec.class,CompressionCodec.class);</li>
</ul>
<h6 id="提高MapTask内存上限"><a href="#提高MapTask内存上限" class="headerlink" title="提高MapTask内存上限"></a>提高MapTask内存上限</h6><p>   mapreduce.map.memory.mb 默认MapTask内存上限1024MB。 可以根据128m数据对应1G内存原则提高该内存。</p>
<h6 id="控制MapTask堆内存大小"><a href="#控制MapTask堆内存大小" class="headerlink" title="控制MapTask堆内存大小"></a>控制MapTask堆内存大小</h6><p>   mapreduce.map.java.opts：控制MapTask堆内存大小。（如果内存不够， 报：java.lang.OutOfMemoryError）</p>
<h6 id="增加MapTask的CPU核数"><a href="#增加MapTask的CPU核数" class="headerlink" title="增加MapTask的CPU核数"></a>增加MapTask的CPU核数</h6><p>   mapreduce.map.cpu.vcores 默认MapTask的CPU核数1。计算密集型任 务可以增加CPU核数</p>
<h6 id="异常重试"><a href="#异常重试" class="headerlink" title="异常重试"></a>异常重试</h6><p>   mapreduce.map.maxattempts每个Map Task最大重试次数，一旦重试 次数超过该值，则认为Map Task运行失败，默认值：4。根据机器 性能适当提高。</p>
<h5 id="Shuffle——-gt-Reduce"><a href="#Shuffle——-gt-Reduce" class="headerlink" title="Shuffle——&gt;Reduce"></a>Shuffle——&gt;Reduce</h5><p><img src="/Hadoop%E6%90%AD%E5%BB%BA%E8%B0%83%E4%BC%98%E7%AC%94%E8%AE%B0/2022-01-24_17-26.png"></p>
<ul>
<li>mapreduce.reduce.shuffle.parallelcopies每个Reduce去Map 中拉取数据的并行数，默认值是5。可以提高到10。</li>
<li>mapreduce.reduce.shuffle.input.buffer.percent Buffer大小占Reduce可用内存的比例，默认值0.7。可以提高到0.8</li>
<li>mapreduce.reduce.shuffle.merge.percent Buffer中的数据达到多少比例 开始写入磁盘，默认值0.66。可以提高到0.75</li>
<li>mapreduce.reduce.memory.mb 默认ReduceTask内存上限1024MB， 根据128m数据对应1G内存原则，适当提高内存到4-6G</li>
<li>mapreduce.reduce.java.opts：控制ReduceTask堆内存大小。（如果内 存不够，报：java.lang.OutOfMemoryError）</li>
<li>mapreduce.reduce.cpu.vcores默认ReduceTask的CPU核数1个。可 以提高到2-4个</li>
<li>mapreduce.reduce.maxattempts每个Reduce Task最大重试次数， 一旦重试次数超过该值，则认为Map Task运行失败，默认值：4。</li>
<li>mapreduce.job.reduce.slowstart.completedmaps当MapTask完成的比 例达到该值后才会为ReduceTask申请资源。默认是0.05。</li>
<li>mapreduce.task.timeout如果一个Task在一定时间内没有任何进入， 即不会读取新的数据，也没有输出数据，则认为该Task处于Block状态， 可能是卡住了，也许永远会卡住，为了防止因为用户程序永远Block住 不退出，则强制设置了一个该超时时间（单位毫秒），默认是600000 （10分钟）。如果你的程序对每条输入数据的处理时间过长，建议将 该参数调大。</li>
<li>如果可以不用Reduce，尽可能不用</li>
</ul>
<h4 id="MapReduce-数据倾斜问题"><a href="#MapReduce-数据倾斜问题" class="headerlink" title="MapReduce 数据倾斜问题"></a>MapReduce 数据倾斜问题</h4><blockquote>
<p>数据频率倾斜——某一个区域的数据量要远远大于其他区域。</p>
<p> 数据大小倾斜——部分记录的大小远远大于平均值。</p>
</blockquote>
<ol>
<li><p>先检查是否空值过多造成的数据倾斜可以直接过滤掉空值；如果想保留空值，就自定义分区，将空值加随机数打 散。最后再二次聚合。 </p>
</li>
<li><p>能在 map 阶段提前处理，最好先在 Map 阶段处理。如：Combiner、MapJoin </p>
</li>
<li><p>设置多个 reduce 个数</p>
</li>
</ol>
<h3 id="Hadoop-Yarn-生产经验"><a href="#Hadoop-Yarn-生产经验" class="headerlink" title="Hadoop-Yarn 生产经验"></a>Hadoop-Yarn 生产经验</h3><blockquote>
<p>参考Yarn笔记</p>
</blockquote>
<h2 id="本机Hadoop学习环境调优"><a href="#本机Hadoop学习环境调优" class="headerlink" title="本机Hadoop学习环境调优"></a>本机Hadoop学习环境调优</h2><blockquote>
<p>虚拟机配置：<br>        4G内存<br>        2核<br>        50G磁盘</p>
<p>使用场景：<br>        多是处理小文件</p>
</blockquote>
<h3 id="HDFS-参数调优"><a href="#HDFS-参数调优" class="headerlink" title="HDFS 参数调优"></a>HDFS 参数调优</h3><p>修改：hadoop-env.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HDFS_NAMENODE_OPTS=&quot;-Dhadoop.security.logger=INFO,RFAS -Xmx1024m&quot;</span><br><span class="line">export HDFS_DATANODE_OPTS=&quot;-Dhadoop.security.logger=ERROR,RFAS -Xmx1024m&quot;</span><br></pre></td></tr></table></figure>

<p>修改 hdfs-site.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- NameNode 有一个工作线程池，默认值是 10 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.handler.count<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>21<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改 core-site.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置垃圾回收时间为 60 分钟 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.trash.interval<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>60<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>分发配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xsync hadoop-env.sh hdfs-site.xml core-site.xml</span><br></pre></td></tr></table></figure>

<h3 id="MapReduce-参数调优"><a href="#MapReduce-参数调优" class="headerlink" title="MapReduce 参数调优"></a>MapReduce 参数调优</h3><p>修改 mapred-site.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 环形缓冲区大小，默认 100m --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.task.io.sort.mb<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 环形缓冲区溢写阈值，默认 0.8 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.map.sort.spill.percent<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>0.80<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- merge 合并次数，默认 10 个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.task.io.sort.factor<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>10<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- maptask 内存，默认 1g； maptask 堆内存大小默认和该值大小一致</span></span><br><span class="line"><span class="comment">mapreduce.map.java.opts --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.map.memory.mb<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>The amount of memory to request from the scheduler for each map task. If this is not specified or is non-positive, it is inferred from mapreduce.map.java.opts and mapreduce.job.heap.memory-mb.ratio. If java-opts are also not specified, we set it to 1024.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- matask 的 CPU 核数，默认 1 个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.map.cpu.vcores<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- matask 异常重试次数，默认 4 次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.map.maxattempts<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>4<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 每个 Reduce 去 Map 中拉取数据的并行数。默认值是 5 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.reduce.shuffle.parallelcopies<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>5<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Buffer 大小占 Reduce 可用内存的比例，默认值 0.7 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.reduce.shuffle.input.buffer.percent<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>0.70<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Buffer 中的数据达到多少比例开始写入磁盘，默认值 0.66。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.reduce.shuffle.merge.percent<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>0.66<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- reducetask 内存，默认 1g；reducetask 堆内存大小默认和该值大小一致</span></span><br><span class="line"><span class="comment">mapreduce.reduce.java.opts --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.reduce.memory.mb<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">description</span>&gt;</span>The amount of memory to request from the scheduler for each reduce task. If this is not specified or is non-positive, it is inferred from mapreduce.reduce.java.opts and mapreduce.job.heap.memory-mb.ratio. If java-opts are also not specified, we set it to 1024.</span><br><span class="line">     <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- reducetask 的 CPU 核数，默认 1 个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.reduce.cpu.vcores<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- reducetask 失败重试次数，默认 4 次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.reduce.maxattempts<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>4<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 当 MapTask 完成的比例达到该值后才会为 ReduceTask 申请资源。默认是 0.05</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.job.reduce.slowstart.completedmaps<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>0.05<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果程序在规定的默认 10 分钟内没有读到数据，将强制超时退出 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.task.timeout<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>600000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Yarn-参数调优"><a href="#Yarn-参数调优" class="headerlink" title="Yarn 参数调优"></a>Yarn 参数调优</h3><p>修改 yarn-site.xml </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 选择调度器，默认容量 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>The class to use as the resource scheduler.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.scheduler.class<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity.CapacityScheduler<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ResourceManager 处理调度器请求的线程数量,默认 50；如果提交的任务数大于 50，可以</span></span><br><span class="line"><span class="comment">增加该值，但是不能超过 3 台 * 2 线程 = 6 线程（去除其他应用程序实际不能超过 3） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Number of threads to handle scheduler interface.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.scheduler.client.thread-count<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 是否让 yarn 自动检测硬件进行配置，默认是 false，如果该节点有很多其他应用程序，建议</span></span><br><span class="line"><span class="comment">手动配置。如果该节点没有其他应用程序，可以采用自动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Enable auto-detection of node capabilities such as memory and CPU.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.resource.detect-hardware-capabilities<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 是否将虚拟核数当作 CPU 核数，默认是 false，采用物理 CPU 核数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Flag to determine if logical processors(such as hyperthreads) should be counted as cores. Only applicable on Linux when yarn.nodemanager.resource.cpu-vcores is set to -1 and yarn.nodemanager.resource.detect-hardware-capabilities is true.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.resource.count-logical-processors-ascores<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 虚拟核数和物理核数乘数，默认是 1.0 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Multiplier to determine how to convert phyiscal cores to vcores. This value is used if yarn.nodemanager.resource.cpu-vcores is set to -1(which implies auto-calculate vcores) and yarn.nodemanager.resource.detect-hardware-capabilities is set to true. The number of vcores will be calculated as number of CPUs * multiplier.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.resource.pcores-vcores-multiplier<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- NodeManager 使用内存数，默认 8G，修改为 4G 内存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Amount of physical memory, in MB, that can be allocated for containers. If set to -1 and yarn.nodemanager.resource.detect-hardware-capabilities is true, it is automatically calculated(in case of Windows and Linux).In other cases, the default is 8192MB.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.resource.memory-mb<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>4096<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- nodemanager 的 CPU 核数，不按照硬件环境自动设定时默认是 8 个，修改为 2 个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Number of vcores that can be allocated for containers. This is used by the RM scheduler when allocating resources for containers. This is not used to limit the number of CPUs used by YARN containers. If it is set to -1 and yarn.nodemanager.resource.detect-hardware-capabilities is true, it is automatically determined from the hardware in case of Windows and Linux.In other cases, number of vcores is 8 by default.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.resource.cpu-vcores<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 容器最小内存，默认 1G --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>The minimum allocation for every container request at the RM in MBs. Memory requests lower than this will be set to the value of this property. Additionally, a node manager that is configured to have less memory than this value will be shut down by the resource manager.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.minimum-allocation-mb<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1024<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 容器最大内存，默认 8G，修改为 2G --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>The maximum allocation for every container request at the RM in MBs. Memory requests higher than this will throw an InvalidResourceRequestException.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.maximum-allocation-mb<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>2048<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 容器最小 CPU 核数，默认 1 个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>The minimum allocation for every container request at the RM in terms of virtual CPU cores. Requests lower than this will be set to the value of this property. Additionally, a node manager that is configured to have fewer virtual cores than this value will be shut down by the resource manager.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.minimum-allocation-vcores<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 容器最大 CPU 核数，默认 4 个，修改为 2 个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>The maximum allocation for every container request at the RM in terms of virtual CPU cores. Requests higher than this will throw an InvalidResourceRequestException.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.maximum-allocation-vcores<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 虚拟内存检查，默认打开，修改为关闭 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Whether virtual memory limits will be enforced for containers.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.vmem-check-enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 虚拟内存和物理内存设置比例,默认 2.1 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Ratio between virtual memory to physical memory when setting memory limits for containers. Container allocations are expressed in terms of physical memory, and virtual memory usage is allowed to exceed this allocation by this ratio.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.vmem-pmem-ratio<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>技术知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop原理</title>
    <url>/Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>本文主要介绍了Hadoop的基本构成（RPC、HDFS、Yarn、MapReduce）。使读者能够理解Hadoop的基本原理。</p>
<span id="more"></span>

<h1 id="Hadoop概述"><a href="#Hadoop概述" class="headerlink" title="Hadoop概述"></a>Hadoop概述</h1><h2 id="Hadoop是什么"><a href="#Hadoop是什么" class="headerlink" title="Hadoop是什么"></a>Hadoop是什么</h2><ol>
<li>Hadoop是一个由A pache基金会所开发的分布式系统基础架构。</li>
<li>主要解决,海量数据的存储和海量数据的分析计算问题。</li>
<li>广义上来说,Hadoop通常是指一个更广泛的概念——Hadoop生态圈。</li>
</ol>
<p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221012210211271.png" alt="image-20221012210211271"></p>
<h2 id="Hadoop-三大发行版本-了解"><a href="#Hadoop-三大发行版本-了解" class="headerlink" title="Hadoop 三大发行版本(了解)"></a>Hadoop 三大发行版本(了解)</h2><h3 id="版本介绍"><a href="#版本介绍" class="headerlink" title="版本介绍"></a>版本介绍</h3><p>Hadoop 三大发行版本:Apache、Cloudera、Hortonworks。</p>
<ul>
<li>Apache 版本最原始(最基础)的版本,对于入门学习最好。2006</li>
<li>Cloudera 内部集成了很多大数据框架,对应产品 CDH。2008</li>
<li>Hortonworks 文档较好,对应产品 HDP。2011</li>
<li>Hortonworks 现在已经被 Cloudera 公司收购,推出新的品牌 CDP。</li>
</ul>
<h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><h4 id="Apache-Hadoop"><a href="#Apache-Hadoop" class="headerlink" title="Apache Hadoop"></a>Apache Hadoop</h4><p>官网地址：<a href="http://hadoop.apache.org/releases.html">http://hadoop.apache.org/releases.html</a><br>下载地址：<a href="https://archive.apache.org/dist/hadoop/common/">https://archive.apache.org/dist/hadoop/common/</a></p>
<h4 id="Cloudera-Hadoop"><a href="#Cloudera-Hadoop" class="headerlink" title="Cloudera Hadoop"></a>Cloudera Hadoop</h4><p>官网地址：<a href="https://www.cloudera.com/downloads/cdh/5-10-0.html">https://www.cloudera.com/downloads/cdh/5-10-0.html</a><br>下载地址：<a href="http://archive-primary.cloudera.com/cdh5/cdh/5/">http://archive-primary.cloudera.com/cdh5/cdh/5/</a></p>
<h4 id="Hortonworks-Hadoop"><a href="#Hortonworks-Hadoop" class="headerlink" title="Hortonworks Hadoop"></a>Hortonworks Hadoop</h4><p>官网地址：<a href="https://hortonworks.com/products/data-center/hdp/">https://hortonworks.com/products/data-center/hdp/</a><br>下载地址：<a href="https://hortonworks.com/downloads/#data-platform">https://hortonworks.com/downloads/#data-platform</a></p>
<h2 id="Hadoop-优势-4-高"><a href="#Hadoop-优势-4-高" class="headerlink" title="Hadoop 优势(4 高)"></a>Hadoop 优势(4 高)</h2><ul>
<li>高可靠性:Hadoop底层维护多个数据副本,所以即使Hadoop某个计算元素或存储出现故障,也不会导致数据的丢失。</li>
</ul>
<p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221012194757354.png" alt="image-20221012194757354"></p>
<ul>
<li>高扩展性:在集群间分配任务数据,可方便的扩展数以千计的节点。</li>
</ul>
<p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221012194910090.png" alt="image-20221012194910090"></p>
<ul>
<li>高效性:在MapReduce的思想下,Hadoop是并行工作的,以加快任务处理速度。</li>
</ul>
<p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221012195023866.png" alt="image-20221012195023866"></p>
<ul>
<li>高容错性:能够自动将失败的任务重新分配。</li>
</ul>
<p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/2022-10-12_19-50.png" alt="2022-10-12_19-50.png"></p>
<h2 id="Hadoop-组成-面试重点"><a href="#Hadoop-组成-面试重点" class="headerlink" title="Hadoop 组成(面试重点)"></a>Hadoop 组成(面试重点)</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>Hadoop主要有4大模块：HDFS、Yarn、MapReduce、Common</p>
<p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221012195923918.png" alt="image-20221012195923918"></p>
<h3 id="Common架构概述"><a href="#Common架构概述" class="headerlink" title="Common架构概述"></a>Common架构概述</h3><p>Common(公共)模块更多地隐藏在幕后，为框架提供基础支持。从Hadoop 0.20版本开始，将原来Hadoop项目的Core部分更名为Hadoop Common</p>
<p>Common：为Hadoop其他模块提供支持实用程序，是整体Hadoop项目的核心。其主要包括一组分布式文件系统、通用I&#x2F;O组件与接口(序列化远程过程调用RPC、持久化数据结构)</p>
<h3 id="HDFS-架构概述"><a href="#HDFS-架构概述" class="headerlink" title="HDFS 架构概述"></a>HDFS 架构概述</h3><p>Hadoop Distributed File System,简称 HDFS,是一个分布式文件系统。</p>
<p>HDFS下分3大组件：NameNode(nn)、DataNode(dn)、Secondary NameNode(2nn)</p>
<ol>
<li>NameNode：存储文件的元数据,如文件名,文件目录结构,文件属性(生成时间、副本数、文件权限),以及每个文件的块列表和块所在的DataNode等。</li>
<li>DataNode：在本地文件系统存储文件块数据,以及块数据的校验和。</li>
<li>Secondary NameNode：在本地文件系统存储文件块数据,以及块数据的校验和。Secondary NameNode并不会存储所有的数据，NameNode损坏只能恢复部分数据。</li>
</ol>
<h3 id="YARN-架构概述"><a href="#YARN-架构概述" class="headerlink" title="YARN 架构概述"></a>YARN 架构概述</h3><p>Yet Another Resource Negotiator 简称 YARN ,另一种资源协调者,是 Hadoop 的资源管理器。</p>
<p>YARN下分4大组件：ResourceManager(RM)、NodeManager(NM)、ApplicationMaster(AM)、Container</p>
<ol>
<li>ResourceManager(RM)：整个集群资源(内存、CPU等)的老大</li>
<li>NodeManager(NM)：整个集群资源(内存、CPU等)的老大</li>
<li>ApplicationMaster(AM)：单个任务运行的老大</li>
<li>Container：容器,相当一台独立的服务器,里面封装了任务运行所需要的资源,如内存、CPU、磁盘、网络等。</li>
</ol>
<p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/2022-10-12_20-27.png" alt="2022-10-12_20-27.png"></p>
<h3 id="MapReduce-架构概述"><a href="#MapReduce-架构概述" class="headerlink" title="MapReduce 架构概述"></a>MapReduce 架构概述</h3><p>MapReduce 将计算过程分为两个阶段:Map 和 Reduce</p>
<ol>
<li>Map 阶段并行处理输入数据</li>
<li>Reduce 阶段对 Map 结果进行汇总</li>
</ol>
<p>MapReduce是一个软件框架，基于该框架能够容易地编写应用程序，这些应用程序能够运行在由上千个商用机器组成的大集群上，并以一种可靠的，具有容错能力的方式并行地处理上TB级别的海量数据集。</p>
<p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/2022-10-12_20-35.png" alt="2022-10-12_20-35.png"></p>
<h3 id="HDFS、YARN、MapReduce-三者关系"><a href="#HDFS、YARN、MapReduce-三者关系" class="headerlink" title="HDFS、YARN、MapReduce 三者关系"></a>HDFS、YARN、MapReduce 三者关系</h3><p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221012204712903.png" alt="image-20221012204712903"></p>
<h2 id="Hadoop-目录结构"><a href="#Hadoop-目录结构" class="headerlink" title="Hadoop 目录结构"></a>Hadoop 目录结构</h2><h3 id="查看-Hadoop-目录结构"><a href="#查看-Hadoop-目录结构" class="headerlink" title="查看 Hadoop 目录结构"></a>查看 Hadoop 目录结构</h3><p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221012205649812.png" alt="image-20221012205649812"></p>
<h3 id="重要目录"><a href="#重要目录" class="headerlink" title="重要目录"></a>重要目录</h3><ol>
<li>bin 目录:存放对 Hadoop 相关服务(hdfs,yarn,mapred)进行操作的脚本</li>
<li>etc 目录:Hadoop 的配置文件目录,存放 Hadoop 的配置文件</li>
<li>lib 目录:存放 Hadoop 的本地库(对数据进行压缩解压缩功能)</li>
<li>sbin 目录:存放启动或停止 Hadoop 相关服务的脚本</li>
<li>share 目录:存放 Hadoop 的依赖 jar 包、文档、和官方案例</li>
</ol>
<h2 id="Hadoop-运行模式"><a href="#Hadoop-运行模式" class="headerlink" title="Hadoop 运行模式"></a>Hadoop 运行模式</h2><p>Hadoop 运行模式包括:本地模式、伪分布式模式、完全分布式模式。</p>
<ol>
<li>本地模式：单机运行,只是用来演示一下官方案例。生产环境不用。</li>
<li>伪分布式模式：也是单机运行,但是具备 Hadoop 集群的所有功能,一台服务器模拟一个分布式的环境。个别缺钱的公司用来测试,生产环境不用。</li>
<li>完全分布式模式：多台服务器组成分布式环境。生产环境使用。</li>
</ol>
<h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><p>​        RPC（Remote Procedure Call）远程过程调用协议，一种通过网络从远程计算机上请求服务，而不需要了解底层网络技术的协议。其过程就是业务处理、计算任务，更直白的说，就是程序，就是想调用本地方法一样调用远程的过程</p>
<p>​        Hadoop 的 RPC 是 Hadoop 的核心通信机制，RPC 主要用于所有 Hadoop 的组件元数据交换，如 MapReduce、Hadoop 分布式系统（HDFS）和Hadoop 的数据库（Hbase）。</p>
<h2 id="RPC的特点"><a href="#RPC的特点" class="headerlink" title="RPC的特点"></a>RPC的特点</h2><ol>
<li>透明性：远程调用其他机器上的程序，对用户来说就像是调用本地方法一样；</li>
<li>高性能：RPC Server能够并发处理多个来自Client的请求；</li>
<li>可控性：jdk中已经提供了一个RPC框架—RMI，但是该PRC框架过于重量级并且可控之处比较少，所以Hadoop RPC实现了自定义的PRC框架。</li>
</ol>
<h2 id="PRC工作原理"><a href="#PRC工作原理" class="headerlink" title="PRC工作原理"></a>PRC工作原理</h2><p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/Hadoop-RPC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p>
<ol>
<li>服务消费方（client）调用以本地调用方式调用服务；</li>
<li>client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</li>
<li>client stub找到服务地址，通过RPCRuntime实例将消息发送到服务端；</li>
<li>RPCRuntime实例收到请求后交给server stub进行解码；</li>
<li>server stub根据解码结果调用本地的服务；</li>
<li>本地服务执行并将结果返回给server stub；</li>
<li>server stub将返回结果打包成消息并发送至消费方；</li>
<li>client stub接收到消息，并进行解码；</li>
<li>服务消费方得到最终结果。</li>
</ol>
<h2 id="Hadoop中的RPC机制"><a href="#Hadoop中的RPC机制" class="headerlink" title="Hadoop中的RPC机制"></a>Hadoop中的RPC机制</h2><p>​        同其他RPC框架一样，Hadoop RPC分为四个部分：</p>
<ol>
<li>序列化层：Clent与Server端通信传递的信息采用了Hadoop里提供的序列化类或自定义的Writable类型；</li>
<li>函数调用层：Hadoop RPC通过动态代理以及java反射实现函数调用；</li>
<li>网络传输层：Hadoop RPC采用了基于TCP&#x2F;IP的socket机制；</li>
<li>服务器端框架层：RPC Server利用java NIO以及采用了事件驱动的I&#x2F;O模型，提高RPC Server的并发处理能力；</li>
</ol>
<p>　　<strong>Hadoop RPC在整个Hadoop中应用非常广泛</strong>，Client、DataNode、NameNode之间的通讯全靠它了。例如：我们平时操作HDFS的时候，使用的是FileSystem类，它的内部有个DFSClient对象，这个对象负责与NameNode打交道。在运行时，DFSClient在本地创建一个NameNode的代理，然后就操作这个代理，这个代理就会通过网络，远程调用到NameNode的方法，也能返回值。</p>
<h2 id="Hadoop-RPC设计技术"><a href="#Hadoop-RPC设计技术" class="headerlink" title="Hadoop RPC设计技术"></a>Hadoop RPC设计技术</h2><ul>
<li><p><strong>动态代理</strong></p>
<p>  动态代理可以提供对另一个对象的访问，同时隐藏实际对象的具体事实，因为代理对象对客户隐藏了实际对象。</p>
</li>
<li><p><strong>反射—动态加载类</strong></p>
<p>  反射机制实在运动状态中，对任意一个类，都能够知道这个类所有属性和方法；对于任意一个对象，都能够调用他的任意一个方法和属性。</p>
</li>
<li><p><strong>序列化</strong></p>
<p>  什么是序列化？序列化就是将数据结构或对象转换成二进制串的过程，也就是编码的过程。</p>
<p>  什么是反序列化？将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。</p>
<p>  为什么需要序列化？转换为二进制串后才好进行网络传输嘛！</p>
<p>  为什么需要反序列化？将二进制转换为对象才好进行后续处理！</p>
</li>
<li><p><strong>非阻塞的异步IO</strong>（NIO）</p>
<p>  非阻塞的异步IO指的是用户调用读写方法是不阻塞的，立刻返回，而且用户不需要关注读写，只需要提供回调操作。内核线程在完成读写后回调用户提供的callback</p>
</li>
</ul>
<h1 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h1><p>​        HDFS(Hadoop Distributed File System),它是一个文件系统,用于存储文件,通过目录树来定位文件;其次,它是分布式的,由很多服务器联合起来实现其功能,集群中的服务器有各自的角色。</p>
<p>​        HDFS 的使用场景:适合一次写入,多次读出的场景。一个文件经过创建、写入和关闭之后就不需要改变。</p>
<p>​        HDFS采用master&#x2F;slave架构。一个HDFS集群由一个NameNode和一定数目的DataNode组成。</p>
<h2 id="HDFS-优缺点"><a href="#HDFS-优缺点" class="headerlink" title="HDFS 优缺点"></a>HDFS 优缺点</h2><h3 id="HDFS优点"><a href="#HDFS优点" class="headerlink" title="HDFS优点"></a>HDFS优点</h3><ol>
<li><p>高容错性</p>
<ul>
<li><p>数据自动保存多个副本。它通过增加副本的形式,提高容错性。</p>
<p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221016211621397.png" alt="image-20221016211621397"></p>
</li>
<li><p>某一个副本丢失以后,它可以自动恢复。</p>
<p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221016211651087.png" alt="image-20221016211651087"></p>
</li>
</ul>
</li>
<li><p>适合处理大数据</p>
<ul>
<li>数据规模:能够处理数据规模达到GB、T B、甚至PB级别的数据;</li>
<li>文件规模:能够处理百万规模以上的文件数量,数量相当之大。</li>
</ul>
</li>
<li><p>可构建在廉价机器上,通过多副本机制,提高可靠性。</p>
</li>
</ol>
<h3 id="HDFS缺点"><a href="#HDFS缺点" class="headerlink" title="HDFS缺点"></a>HDFS缺点</h3><ol>
<li><p>不适合低延时数据访问,比如毫秒级的存储数据,是做不到的。</p>
</li>
<li><p>无法高效的对大量小文件进行存储。</p>
<ul>
<li>存储大量小文件的话,它会占用NameNode大量的内存来存储文件目录和块信息。这样是不可取的,因为NameNode的内存总是有限的。</li>
<li>小文件存储的寻址时间会超过读取时间,它违反了HDFS的设计目标。</li>
</ul>
</li>
<li><p>不支持并发写入、文件随机修改。</p>
<ul>
<li><p>仅支持数据append(追加),不支持文件的随机修改。</p>
</li>
<li><p>一个文件只能有一个写,不允许多个线程同时写。</p>
<p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221016212701958.png" alt="image-20221016212701958"></p>
</li>
</ul>
</li>
</ol>
<h2 id="HDFS-组成架构"><a href="#HDFS-组成架构" class="headerlink" title="HDFS 组成架构"></a>HDFS 组成架构</h2><p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221016213946647.png" alt="image-20221016213946647"></p>
<ol>
<li>NameNode(nn):就是Master,它是一个主管、管理者。<ol>
<li>管理HDFS的命名空间;</li>
<li>配置副本策略;</li>
<li>管理数据块(Block)映射信息;</li>
<li>处理客户端读写请求;</li>
</ol>
</li>
<li>DataNode:就是Slave。NameNode下达命令,DataNode执行实际的操作。<ol>
<li>存储实际的数据块;</li>
<li>执行数据块的读&#x2F;写操作;</li>
</ol>
</li>
<li>Client:就是客户端。<ol>
<li>文件切分。文件上传HDF S的时候,Client将文件切分成一个一个的Block,然后进行上传;</li>
<li>与NameNode交互,获取文件的位置信息;</li>
<li>与DataNode交互,读取或者写入数据;</li>
<li>Client提供一些命令来管理HDFS,比如NameNode格式化;</li>
<li>Client可以通过一些命令来访问HDFS,比如对HDFS增删查改操作;</li>
</ol>
</li>
<li>Block：文件系统读写的最小单元。<ol>
<li>可根据实际的工作效率和集群吞吐量修改Block大小;</li>
<li>切分时按大小进行切分，不足值单独成块;</li>
</ol>
</li>
<li>Secondary NameNode:并非NameNode的热备。当NameNode挂掉的时候,它并不能马上替换NameNode并提供服务。<ol>
<li>辅助NameNode,分担其工作量,比如定期合并Fsimage和Edits,并推送给NameNode ;</li>
<li>在紧急情况下,可辅助恢复NameNode。</li>
</ol>
</li>
</ol>
<h2 id="HDFS-文件块大小-面试重点"><a href="#HDFS-文件块大小-面试重点" class="headerlink" title="HDFS 文件块大小(面试重点)"></a>HDFS 文件块大小(面试重点)</h2><ol>
<li>HDFS的块设置太小,会增加寻址时间,程序一直在找块的开始位置;</li>
<li>如果块设置的太大,从磁盘传输数据的时间会明显大于定位这个块开始位置所需的时间。导致程序在处理这块数据时,会非常慢。</li>
<li>HDFS块的大小设置主要取决于磁盘传输速率。</li>
<li>HDFS中 的 文 件 在 物 理 上 是 分 块 存 储 ( Block ) , 块 的 大 小 可 以 通 过 配 置 参 数( dfs.blocksize)来规定,默认大小在Hadoop2.x&#x2F;3.x版本中是128M,1.x版本中是64M。</li>
<li>Block计算公式：<ol>
<li>如果寻址时间约为10ms,即查找到目标block的时间为10ms。</li>
<li>寻址时间为传输时间的1%时,则为最佳状态(专家)。因此,传输时间&#x3D;10ms&#x2F;0.01&#x3D;1000ms&#x3D;1s</li>
<li>而目前磁盘的传输速率普遍为100MB&#x2F;s。要实际情况而定</li>
<li>block大小&#x3D;1s*100MB&#x2F;s&#x3D;100MB</li>
</ol>
</li>
</ol>
<h2 id="HDFS的副本复制"><a href="#HDFS的副本复制" class="headerlink" title="HDFS的副本复制"></a>HDFS的副本复制</h2><p>​        HDFS被设计成能够在一个大集群中跨机器可靠地存储超大文件。它将每个文件存储成一系列的数据块，除了最后一个，所有的数据块都是同样大小的。为了容错，文件的所有数据块都会有副本。每个文件的数据块大小和副本系数都是可配置的。应用程序可以指定某个文件的副本数目。副本系数可以在文件创建的时候指定，也可以在之后改变。HDFS中的文件都是一次性写入的，并且严格要求在任何时候只能有一个写入者。</p>
<p>​        Namenode全权管理数据块的复制，它周期性地从集群中的每个Datanode接收心跳信号和块状态报告(Blockreport)。接收到心跳信号意味着该Datanode节点工作正常。块状态报告包含了一个该Datanode上所有数据块的列表。</p>
<p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221017152744622.png" alt="image-20221017152744622"></p>
<p>副本节点选择:</p>
<ol>
<li>第一个副本在Client所处的节点上。如果客户端在集群外,随机选一个。</li>
<li>第二个副本在另一个机架的随机一个节点</li>
<li>第三个副本在第二个副本所在机架的随机节点</li>
</ol>
<p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221017153441640.png" alt="image-20221017153441640"></p>
<h2 id="HDFS-的读写流程-面试重点"><a href="#HDFS-的读写流程-面试重点" class="headerlink" title="HDFS 的读写流程(面试重点)"></a>HDFS 的读写流程(面试重点)</h2><h3 id="HDFS-读数据流程"><a href="#HDFS-读数据流程" class="headerlink" title="HDFS 读数据流程"></a>HDFS 读数据流程</h3><p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/hdsf-read.png" alt="hdsf-read"></p>
<ol>
<li>首先调用FileSystem对象的open方法，其实是一个DistributedFileSystem类的实例。</li>
<li>客户端通过 DistributedFileSystem 向 NameNode 请求下载文件, NameNode通过查询元数据,找到文件块所在的 DataNode 地址，并按照Hadoop结构拓扑排序，距离客户端近的排在前面。</li>
<li>前两步会返回一个FSDataInputStream对象，该对象会被封装成DFSInputStream对象以方便管理DataNode和NameNode数据流。客户端调用read方法DFSInputStream找到最近的第一个数据所在的DataNode连接。</li>
<li>客户端以 Packet 为单位接收,先在本地缓存,然后写入目标文件。</li>
<li>如果第一块读完了系统会关闭（close）指向第一块的DataNode连接，接着读取第二块。</li>
</ol>
<h3 id="HDFS-写数据流程"><a href="#HDFS-写数据流程" class="headerlink" title="HDFS 写数据流程"></a>HDFS 写数据流程</h3><p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/hdfs-write.png" alt="hdfs-write.png"></p>
<ol>
<li>客 户 端 通 过 Distributed FileSystem 模 块 向 NameNode 请 求 上 传 文 件 ,NameNode 检查目标文件是否已存在,父目录是否存在。</li>
<li>NameNode 返回是否可以上传。</li>
<li>客户端请求第一个 Block 上传到哪几个 DataNode 服务器上。</li>
<li>NameNode 返回 3 个 DataNode 节点，分别为 dn1、dn2、dn3。。</li>
<li>客户端通过 FSDataOutputStream 模块请求 dn1 上传数据, dn1 收到请求会继续调用 dn2,然后 dn2 调用 dn3,将这个通信管道建立完成。<br>NameNode会返回一个Ack到前一个NameNode逐级应答客户端。</li>
<li>客户端开始往 dn1 上传第一个 Block (先从磁盘读取数据放到一个本地内存缓存),以 Packet 为单位,dn1 收到一个 Packet 就会传给 dn2,dn2 传给 dn3;dn1 每传一个packet 会放入一个应答队列等待应答。</li>
<li>当一个 Block 传输完成之后,客户端再次请求 NameNode 上传第二个 Block 的服务器。(重复执行 5-12 步)。</li>
</ol>
<h2 id="HDFS数据删除与恢复"><a href="#HDFS数据删除与恢复" class="headerlink" title="HDFS数据删除与恢复"></a>HDFS数据删除与恢复</h2><p>​        HDFS的数据删除与传统的数据删除有很大的区别。在传统文件系统中要删除文件，首先要找到文件位置，然后把文件删除。而在HDFS中，由于文件是一个大文件被切割成若干个小文件Block，Block以多副本的形式存储在不同的DataNode中，文件位置的存储位置的映射在NameNode中，如果要找到位置多线程一次删除会给NameNode很大的压力，且删除时间长。所以HDFS把删除任务拆解为不同的线程。<br>​        当HDFS的数据被删除时，不会立即从HDFS中删除。而是将文件移动到&#x2F;trash中。只要文件还在&#x2F;trash目录中就可以快速恢复。文件的保存时间是有限的，只要超过时间线文件就会被删除。当前默认的时间为0秒，即删除的文件不存储在&#x2F;trash中，该值可以在core-site.xml中配置参数fs.trash.interval进行设定。</p>
<h1 id="YARN"><a href="#YARN" class="headerlink" title="YARN"></a>YARN</h1><p>​        YARN 是一个资源调度平台,负责为运算程序提供服务器运算资源,相当于一个分布式的操作系统平台,而 MapReduce 等运算程序则相当于运行于操作系统之上的应用程序。</p>
<h2 id="Yarn-基础架构"><a href="#Yarn-基础架构" class="headerlink" title="Yarn 基础架构"></a>Yarn 基础架构</h2><blockquote>
<p> YARN 主 要 由 ：ResourceManager 、 NodeManager 、 ApplicationMaster 、Container 等组件构成。</p>
</blockquote>
<p>各组件的作用：</p>
<ul>
<li><p><strong>ResourceManager</strong></p>
<ol>
<li>处理客户端请求</li>
<li>监控NodeManager</li>
<li>启动或监控ApplicationMaster</li>
<li>资源的分配与调度</li>
</ol>
</li>
<li><p><strong>NodeManager</strong></p>
<ol>
<li>管理单个节点上的资源</li>
<li>处理来自ResourceManager的命令</li>
<li>处理来自ApplicationMaster的命令</li>
</ol>
</li>
<li><p><strong>ApplicationMaster</strong></p>
<ol>
<li>为应用程序申请资源并分配给内部的任务</li>
<li>任务的监控与容错</li>
</ol>
</li>
<li><p><strong>Container</strong></p>
<ol>
<li>Container 是 YARN 中的资源抽象,它封装了某个节点上的多维度资源,如内存、CPU、磁盘、网络等。</li>
</ol>
</li>
</ul>
<p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/yarn-%E6%9E%B6%E6%9E%84.png" alt="yarn-架构.png"></p>
<p>工作流程：</p>
<ol>
<li><p>Client向ResourceManager提交作业（可以是Spark&#x2F;Mapreduce作业）</p>
</li>
<li><p>ResourceManager会为这个作业分配一个container</p>
</li>
<li><p>ResourceManager与NodeManager通信，要求NodeManger在刚刚分配好的container上启动应用程序的Application Master</p>
</li>
<li><p>Application Master先去向ResourceManager注册，而后ResourceManager会为各个任务申请资源，并监控运行情况</p>
</li>
<li><p>Application Master采用轮询（polling）方式向ResourceManager申请并领取资源（通过RPC协议通信）</p>
</li>
<li><p>Application Manager申请到了资源以后，就和NodeManager通信，要求NodeManager启动任务</p>
</li>
<li><p>最后，NodeManger启动作业对应的任务。</p>
</li>
</ol>
<h2 id="Yarn-工作机制"><a href="#Yarn-工作机制" class="headerlink" title="Yarn 工作机制"></a>Yarn 工作机制</h2><blockquote>
<p>下图以MR程序任务提交为例。Container 是 YARN 中 的资源抽象</p>
<p>在 Spark 中负责准备 Task 环境和执行的是 Executor</p>
<p>在 Flink 中 TaskManager 是任务容器</p>
</blockquote>
<p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/yarn-%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6.png" alt="yarn-工作机制"></p>
<ol>
<li>MR 程序提交到客户端所在的节点。</li>
<li>YarnRunner 向 ResourceManager 申请一个 Application。</li>
<li>RM 将该应用程序的资源路径返回给 YarnRunner。</li>
<li>该程序将运行所需资源提交到 HDFS 上。</li>
<li>程序资源提交完毕后，申请运行 mrAppMaster。</li>
<li>RM 将用户的请求初始化成一个 Task。</li>
<li>其中一个 NodeManager 领取到 Task 任务。</li>
<li>该 NodeManager 创建容器 Container，并产生 MRAppmaster 。</li>
<li>Container 从 HDFS 上拷贝资源到本地。</li>
<li>MRAppmaster 向 RM 申请运行 MapTask 资源。</li>
<li>RM 将运行 MapTask 任务分配给另外两个 NodeManager，另两个 NodeManager 分 别领取任务并创建容器。</li>
<li>MR 向两个接收到任务的 NodeManager 发送程序启动脚本，这两个 NodeManager 分别启动 MapTask，MapTask 对数据分区排序。</li>
<li>MrAppMaster 等待所有 MapTask 运行完毕后，向 RM 申请容器，运行 ReduceTask。</li>
<li>ReduceTask 向 MapTask 获取相应分区的数据。</li>
<li>程序运行完毕后，MR 会向 RM 申请注销自己。</li>
</ol>
<h2 id="Yarn-调度器和调度算法"><a href="#Yarn-调度器和调度算法" class="headerlink" title="Yarn 调度器和调度算法"></a>Yarn 调度器和调度算法</h2><h3 id="先进先出调度器-FIFO"><a href="#先进先出调度器-FIFO" class="headerlink" title="先进先出调度器(FIFO)"></a>先进先出调度器(FIFO)</h3><h4 id="先进先出调度器特点"><a href="#先进先出调度器特点" class="headerlink" title="先进先出调度器特点"></a>先进先出调度器特点</h4><p>FIFO 调度器(First In First Out):单队列,根据提交作业的先后顺序,先来先服务。</p>
<p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221022190341795.png" alt="image-20221022190341795"></p>
<h4 id="先进先出调度器的优缺点"><a href="#先进先出调度器的优缺点" class="headerlink" title="先进先出调度器的优缺点"></a>先进先出调度器的优缺点</h4><p><strong>优点</strong>:简单易懂;<br><strong>缺点</strong>:不支持多队列,生产环境很少使用;</p>
<h3 id="容量调度器-Capacity-Scheduler"><a href="#容量调度器-Capacity-Scheduler" class="headerlink" title="容量调度器(Capacity Scheduler)"></a>容量调度器(Capacity Scheduler)</h3><h4 id="容量调度器特点"><a href="#容量调度器特点" class="headerlink" title="容量调度器特点"></a>容量调度器特点</h4><p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/%E5%AE%B9%E9%87%8F%E8%B0%83%E5%BA%A6%E5%99%A8%E7%89%B9%E7%82%B9.png" alt="容量调度器特点"></p>
<ol>
<li><p><strong>多队列</strong>:每个队列可配置一定的资源量,每个队列采用FIFO调度策略。</p>
</li>
<li><p><strong>容量保证</strong>:管理员可为每个队列设置资源最低保证和资源使用上限。</p>
</li>
<li><p><strong>灵活性</strong>:如果一个队列中的资源有剩余,可以暂时共享给那些需要资源的队列,而一旦该队列有新的应用程序提交,则其他队列借调的资源会归还给该队列。</p>
</li>
<li><p><strong>多租户</strong>:</p>
<ol>
<li>支持多用户共享集群和多应用程序同时运行。</li>
<li>为了防止同一个用户的作业独占队列中的资源,该调度器会对同一用户提交的作业所占资源量进行限定。</li>
</ol>
</li>
<li><p><strong>安全保证</strong>：每个队列有严格的ACL列表规定它的访问用户，每个用户可指定哪些用户允许查看自己应用程序的运行状态或者控制应用程序（比如杀死应用程序）。此外，管理员可指定队列管理员和集群系统管理员</p>
</li>
<li><p><strong>动态更新配置文件</strong>：管理员可根据需要动态修改各种配置参数，以实现在线集群管理</p>
</li>
</ol>
<h4 id="容量调度器资源分配算法"><a href="#容量调度器资源分配算法" class="headerlink" title="容量调度器资源分配算法"></a>容量调度器资源分配算法</h4><p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/%E5%AE%B9%E9%87%8F%E8%B0%83%E5%BA%A6%E5%99%A8%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95.png" alt="容量调度器资源分配算法"></p>
<ol>
<li><strong>队列资源分配</strong><ul>
<li>从root开始,使用深度优先算法,优先选择资源占用率最低的队列分配资源。</li>
</ul>
</li>
<li><strong>作业资源分配</strong><ul>
<li>默认按照提交作业的优先级和提交时间顺序分配资源。</li>
</ul>
</li>
<li><strong>容器资源分配</strong><ol>
<li>按照容器的优先级分配资源;</li>
<li>如果优先级相同,按照数据本地性原则:<ol>
<li>任务和数据在同一节点</li>
<li>任务和数据在同一机架</li>
<li>任务和数据不在同一节点也不在同一机架</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="公平调度器-Fair-Scheduler"><a href="#公平调度器-Fair-Scheduler" class="headerlink" title="公平调度器(Fair Scheduler)"></a>公平调度器(Fair Scheduler)</h3><h4 id="公平调度器特点"><a href="#公平调度器特点" class="headerlink" title="公平调度器特点"></a>公平调度器特点</h4><p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/%E5%85%AC%E5%B9%B3%E8%B0%83%E5%BA%A6%E5%99%A8%E7%89%B9%E7%82%B9.png" alt="公平调度器特点"></p>
<ol>
<li><strong>与容量调度器相同点</strong><ul>
<li>多队列:支持多队列多作业</li>
<li>容量保证:管理员可为每个队列设置资源最低保证和资源使用上线</li>
<li>灵活性:如果一个队列中的资源有剩余,可以暂时共享给那些需要资源的队列,而一旦该队列有新的应用程序提交,则其他队列借调的资源会归还给该队列。</li>
<li>多租户:支持多用户共享集群和多应用程序同时运行;为了防止同一个用户的作业独占队列中的资源,该调度器会对同一用户提交的作业所占资源量进行限定。</li>
</ul>
</li>
<li><strong>与容量调度器不同点</strong><ul>
<li>核心调度策略不同<ul>
<li>容量调度器:优先选择资源利用率低的队列</li>
<li>公平调度器:优先选择对资源的缺额比例大的</li>
</ul>
</li>
<li>每个队列可以单独设置资源分配方式<ul>
<li>容量调度器:FIFO 、 DRF</li>
<li>公平调度器:FIFO 、FAIR、DRF</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="公平调度器-缺额"><a href="#公平调度器-缺额" class="headerlink" title="公平调度器-缺额"></a>公平调度器-缺额</h4><p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/%E5%85%AC%E5%B9%B3%E8%B0%83%E5%BA%A6%E5%99%A8-%E7%BC%BA%E9%A2%9D.png" alt="公平调度器-缺额"></p>
<ol>
<li>公平调度器设计目标是:在时间尺度上,所有作业获得公平的资源。某一时刻一个作业应获资源和实际获取资源的差距叫“ 缺额”</li>
<li>调度器会优先为缺额大的作业分配资源</li>
</ol>
<h1 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h1><p>​    MapReduce 是一个分布式运算程序的编程框架,是用户开发“基于 Hadoop 的数据分析应用”的核心框架。<br>​    MapReduce 核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序,并发运行在一个 Hadoop 集群上。</p>
<h2 id="MapReduce-优缺点"><a href="#MapReduce-优缺点" class="headerlink" title="MapReduce 优缺点"></a>MapReduce 优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><strong>MapReduce 易于编程</strong>：<ul>
<li>它简单的实现一些接口,就可以完成一个分布式程序,这个分布式程序可以分布到大量廉价的 PC 机器上运行。也就是说你写一个分布式程序,跟写一个简单的串行程序是一模一样的。就是因为这个特点使得 MapReduce 编程变得非常流行。</li>
</ul>
</li>
<li><strong>良好的扩展性</strong>：<ul>
<li>当你的计算资源不能得到满足的时候,你可以通过简单的增加机器来扩展它的计算能力。</li>
</ul>
</li>
<li><strong>高容错性</strong>：<ul>
<li>MapReduce 设计的初衷就是使程序能够部署在廉价的 PC 机器上,这就要求它具有很高的容错性。比如其中一台机器挂了,它可以把上面的计算任务转移到另外一个节点上运行,不至于这个任务运行失败,而且这个过程不需要人工参与,而完全是由 Hadoop 内部完成的。</li>
</ul>
</li>
<li><strong>适合 PB 级以上海量数据的离线处理</strong>：<ul>
<li>可以实现上千台服务器集群并发工作,提供数据处理能力。</li>
</ul>
</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><p><strong>不擅长实时计算</strong></p>
<ul>
<li>MapReduce 无法像 MySQL 一样,在毫秒或者秒级内返回结果。</li>
</ul>
</li>
<li><p><strong>不擅长流式计算</strong></p>
<ul>
<li>流式计算的输入数据是动态的,而 MapReduce 的输入数据集是静态的,不能动态变化。这是因为 MapReduce 自身的设计特点决定了数据源必须是静态的。</li>
</ul>
</li>
<li><p><strong>不擅长 DAG(有向无环图)计算</strong></p>
<ul>
<li>多个应用程序存在依赖关系,后一个应用程序的输入为前一个的输出。在这种情况下,MapReduce 并不是不能做,而是使用后,每个 MapReduce 作业的输出结果都会写入到磁盘,会造成大量的磁盘 IO,导致性能非常的低下。</li>
</ul>
</li>
</ul>
<h2 id="MapReduce-on-YARN-工作机制"><a href="#MapReduce-on-YARN-工作机制" class="headerlink" title="MapReduce on YARN 工作机制"></a>MapReduce on YARN 工作机制</h2><blockquote>
<p>[MapReduce 在 YARN 详细的过程](#Yarn 工作机制)</p>
</blockquote>
<p>一个完整的 MapReduce 程序在分布式运行时有三类实例进程:</p>
<ol>
<li>MRAppMaster:负责整个程序的过程调度及状态协调。</li>
<li>MapTask:负责 Map 阶段的整个数据处理流程。</li>
<li>ReduceTask:负责 Reduce 阶段的整个数据处理流程。</li>
</ol>
<p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/MR-on-YARN.png"></p>
<h2 id="MapReduce-进程"><a href="#MapReduce-进程" class="headerlink" title="MapReduce 进程"></a>MapReduce 进程</h2><p>一个完整的 MapReduce 程序在分布式运行时有三类实例进程:</p>
<ul>
<li>MrAppMaster:负责整个程序的过程调度及状态协调。</li>
<li>MapTask:负责 Map 阶段的整个数据处理流程。</li>
<li>ReduceTask:负责 Reduce 阶段的整个数据处理流程。</li>
</ul>
<h2 id="MR演示计算模型"><a href="#MR演示计算模型" class="headerlink" title="MR演示计算模型"></a>MR演示计算模型</h2><p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/MR%E6%BC%94%E7%A4%BA%E8%AE%A1%E7%AE%97%E6%A8%A1%E5%9E%8B.png" alt="MR演示计算模型.png"></p>
<ol>
<li>MapReduce运算程序一般需要分成2个阶段:Map阶段和Reduce阶段</li>
<li>Map阶段的并发MapT ask,完全并行运行,互不相干</li>
<li>第二个阶段的 ReduceTask 并发实例互不相干,但是他们的数据依赖于上一个阶段的所有 MapTask 并发实例的输出。</li>
<li>MapReduce 编程模型只能包含一个 Map 阶段和一个 Reduce 阶段,如果用户的业务逻辑非常复杂,那就只能多个 MapReduce 程序,串行运行。</li>
</ol>
<h2 id="InputFormat-数据输入"><a href="#InputFormat-数据输入" class="headerlink" title="InputFormat 数据输入"></a>InputFormat 数据输入</h2><h3 id="切片与-MapTask-并行度决定机制"><a href="#切片与-MapTask-并行度决定机制" class="headerlink" title="切片与 MapTask 并行度决定机制"></a>切片与 MapTask 并行度决定机制</h3><ul>
<li>MapTask 的并行度决定 Map 阶段的任务处理并发度,进而影响到整个 Job 的处理速度。</li>
<li>数据块:Block 是 HDFS 物理上把数据分成一块一块。数据块是 HDFS 存储数据单位。</li>
<li>数据切片:数据切片只是在逻辑上对输入进行分片，是一个分片长度和一个记录数据位置的数组,并不会在磁盘上将其切分成片进行存储。数据切片是 MapReduce 程序计算输入数据的单位,一切片会对应启动一个MapTask。</li>
</ul>
<h3 id="分片机制"><a href="#分片机制" class="headerlink" title="分片机制"></a>分片机制</h3><p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/%E5%88%86%E7%89%87.png" alt="分片.png"></p>
<ul>
<li>一个Job的Map阶段并行度由客户端在提交Job时的切片数决定</li>
<li>每一个Split切片分配一个MapTask并行实例处理</li>
<li>默认情况下,切片大小&#x3D;BlockSize</li>
<li>切片时不考虑数据集整体,而是逐个针对每一个文件单独切片</li>
</ul>
<p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%8D%95%E7%8B%AC%E5%88%87%E7%89%87.png" alt="每一个文件单独切片"></p>
<h2 id="Map——-gt-Shuffle"><a href="#Map——-gt-Shuffle" class="headerlink" title="Map——&gt;Shuffle"></a>Map——&gt;Shuffle</h2><p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/map-suffle.png" alt="map-suffle"></p>
<p>1.规划阶段<br>客户端submit()前，根据配置信息形成一个任务分配规划，即切片规划；submit()提交首先验证输入输出路径，提交切片信息、jar包(集群模式会提交，本地模式不会提交)、配置文件等；根据切片数计算需要起MapTask的个数</p>
<p>2.Read 阶段<br>MapTask通过RecordReader逻辑从输入的InputSplit中解析出一个个key-value，自定义InputFormat将在这里调用</p>
<p>3.Map 阶段<br>将解析出的key-value交给自定义的map()函数，并产生一系列新的key-value</p>
<p>4.Collect 阶段<br>context.write()后内部会调用OutPutCollectior.collect()输出，并调用分区函数（默认HashPartitioner）对key进行分区后写入一个环形内存缓冲区中</p>
<h2 id="Shuffle"><a href="#Shuffle" class="headerlink" title="Shuffle"></a>Shuffle</h2><p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/image-20221026175208824.png" alt="image-20221026175208824"></p>
<p>​        map()之后reduce()之前的所有MapTask和ReduceTask工作流程称为shuffle</p>
<p>​        map()的context.write()提交数据到collector（收集器），collector通过调用collect()对数据进行操作包括调用Partitioner的分区方法（默认HashPartitioner可自定义）根据k对kv进行分区后写入环形缓冲区（抽象概念本质是一个字节数据）当写入的数据达到环形缓冲区大小的80%触发溢写线程，线程启动后先对这80%的内存先按照分区数排序每个分区内单独按照key进行排序（快速排序），若检测到有Combiner则调用最终一次溢写生成一个临时文件，当map()方法结束MapTask对所有的溢写临时文件再次进行归并排序，若检测到Combiner则调用最终一个MapTask输出一个文件等待ReduceTask拉取。</p>
<p>​        当所有的MapTask结束后启动ReduceTask，ReduceTask根据自己的编号去对应的分区拉取数据到内存，若数据过多也会触发溢写操作，将数据写到磁盘，在拉取数据的过程中ReduceTask同时启动两个后台线程对内存数据和磁盘文件进行合并，最终对所有文件进行归并排序，若监测到Combiner则调用，最终根据key的不同将数据发送给reduce()</p>
<h2 id="Shuffle——-gt-Reduce"><a href="#Shuffle——-gt-Reduce" class="headerlink" title="Shuffle——&gt;Reduce"></a>Shuffle——&gt;Reduce</h2><p><img src="/./Hadoop%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/suffle-reduce.png" alt="suffle-reduce"></p>
<p>1.Copy 阶段<br>简单地拉取数据ReduceTask根据自己的编号去对应的分区拉取数据到内存，如果数据过大超过内存数也会触发溢写操作，将数据写到磁盘中</p>
<p>2.Merge 阶段<br>和Copy阶段同时进行，ReduceTask会启动连个线程对内存和磁盘数据进行合并，方式内存使用过多和磁盘磁盘文件太多</p>
<p>3.Sort 阶段<br>把分散的数据文件再次合并成一个大文件，再进行一次归并排序</p>
<p>4.Reduce 阶段<br>reduce()将计算结果写到HDFS上</p>
<h1 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h1><p><a href="https://hadoop.apache.org/">Hadoop官网</a></p>
<p><a href="https://weread.qq.com/web/bookDetail/fbf3275072037f1afbfd830">Hadoop集群程序设计与开发（王宏志、李春静）</a></p>
<p><a href="https://blog.csdn.net/skylibiao/article/details/85713246">yarn工作原理</a></p>
<p><a href="https://www.jianshu.com/p/25788c6caf49">YARN Capacity Scheduler（容量调度器）</a></p>
<p><a href="https://blog.csdn.net/u012369535/article/details/87916298#t1">MapReduce工作原理详解（学习笔记）</a></p>
<p><a href="https://blog.csdn.net/yumi6666/article/details/82526276">MapReduce中FileInputFormat的文件切片机制</a></p>
<p><a href="https://kpretty.tech/archives/hadoop#12-hadoop-%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F">Hadoop 核心原理</a></p>
<p><a href="https://cloud.tencent.com/developer/article/2021745">RPC框架</a></p>
<p><a href="https://www.cnblogs.com/edisonchou/p/4285817.html">Hadoop RPC机制的使用 </a></p>
<p><a href="https://www.bilibili.com/video/BV1Qp4y1n7EN/?spm_id_from=333.337.search-card.all.click&vd_source=5b52366bc13268f3533facca1424684b">Hadoop尚硅谷</a></p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>    本文撰写的目的是为了使刚接触Linux的小白更好的操作使用Linux，以及作为个人的备忘录。文章介绍的命令是本在Linux系统日常使用中常用到的，或者是在服务器上开发所用到的高频率命令。</p>
<span id="more"></span>

<h1 id="切换目录：cd"><a href="#切换目录：cd" class="headerlink" title="切换目录：cd"></a>切换目录：cd</h1><h2 id="cd命令格式"><a href="#cd命令格式" class="headerlink" title="cd命令格式"></a>cd命令格式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> [目录路径]</span><br></pre></td></tr></table></figure>

<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p><strong>[目录路径]</strong> 可以是绝对路径也可以是相对路径，常见的相对路径有：</p>
<ul>
<li><p>.&#x2F;    表示当前目录</p>
</li>
<li><p>..&#x2F;   表示上一级目录</p>
</li>
<li><p>~    表示用户主目录（&#x2F;home&#x2F;user）</p>
</li>
<li><p>-    表示上一次工作路径</p>
</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>进入根目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /</span><br></pre></td></tr></table></figure>

<p>进入 “home” 目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">cd</span></span><br></pre></td></tr></table></figure>

<p>进入上一次工作路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> -</span><br></pre></td></tr></table></figure>

<p>进入上一级目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../</span><br></pre></td></tr></table></figure>

<h1 id="查询当前目录路径：pwd"><a href="#查询当前目录路径：pwd" class="headerlink" title="查询当前目录路径：pwd"></a>查询当前目录路径：pwd</h1><blockquote>
<p>这是一个相当常用的命令，一般在写配置文件时常常要指定一个目录或者文件。<br>所以，会在写文件时候提前wpd显示目录路径进行复制。</p>
</blockquote>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure>

<h2 id="拓展-1"><a href="#拓展-1" class="headerlink" title="拓展"></a>拓展</h2><p>在<em>终端</em>中的<u><strong>复制</strong></u>快捷键是：Ctrl + Shift + C<br>在<em>终端</em>中的<strong>粘贴</strong>快捷键是：Ctrl + Shift + V</p>
<h1 id="查询文件命令：ls"><a href="#查询文件命令：ls" class="headerlink" title="查询文件命令：ls"></a>查询文件命令：ls</h1><h2 id="命令格式-1"><a href="#命令格式-1" class="headerlink" title="命令格式"></a>命令格式</h2><p>不加 <strong>[目录路径]</strong> 默认为当前目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> [目录路径]</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li><strong>-l</strong>：除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来</li>
<li><strong>-a</strong>：显示所有目录和文件（包括隐藏目录）</li>
<li><strong>-A</strong>：列出除.及..的其它文件</li>
<li><strong>-r</strong>：反序排列</li>
<li><strong>-S</strong>：以文件大小排序</li>
</ul>
<h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><p>按大小反序显示文件详细信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lrS</span><br></pre></td></tr></table></figure>

<p>按修改时间反序排序，并显示文件详细信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lrt</span><br></pre></td></tr></table></figure>

<p>列出当前目录中所有以”t”开头的目录的详细内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l t*</span><br></pre></td></tr></table></figure>

<p>列出文件绝对路径（不包含隐藏文件）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> | sed <span class="string">&quot;s:^:`pwd`/:&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="创建目录-文件夹-：mkdir"><a href="#创建目录-文件夹-：mkdir" class="headerlink" title="创建目录(文件夹)：mkdir"></a>创建目录(文件夹)：mkdir</h1><h2 id="命令格式-2"><a href="#命令格式-2" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> [参数] [目录名]</span><br></pre></td></tr></table></figure>

<h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><ul>
<li><strong>-m</strong>   ：对新建目录设置存取权限，也可以用 chmod 命令设置</li>
<li><strong>-p</strong>    ：可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后，系统将自动建立好那些尚不在的目录，即一次可以建立多个目录。</li>
</ul>
<h2 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h2><p>当前工作目录下创建名为 t的文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> t</span><br></pre></td></tr></table></figure>

<p>在 tmp 目录下创建路径为 test&#x2F;t1&#x2F;t 的目录，若不存在，则创建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /tmp/test/t1/t</span><br></pre></td></tr></table></figure>

<h1 id="删除命令：rm"><a href="#删除命令：rm" class="headerlink" title="删除命令：rm"></a>删除命令：rm</h1><h2 id="命令格式-3"><a href="#命令格式-3" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> [选项] 文件(目录)…</span><br></pre></td></tr></table></figure>

<h2 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h2><ul>
<li><p><strong>-r</strong>    ：删除一个目录中的一个或多个文件或目录，如果没有使用 -r 选项，则 rm 不会删除目</p>
</li>
<li><p><strong>-i</strong>    ：删除任何文件，删除前逐一询问确认</p>
</li>
<li><p><strong>-rf</strong>    ：删除子目录及子目录中所有档案删除，并且不用确认</p>
</li>
</ul>
<h2 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h2><p>删除任何 .log结尾的文件，删除前逐一询问确认</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -i *.<span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<p>删除 test 子目录及子目录中所有档案删除，并且不用一一确认：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>删除以 -f 开头的文件</p>
<blockquote>
<p>文件（目录）以 “-”开头会让命令误认为是参数，所以加上“–“进行分隔</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -- -f*</span><br></pre></td></tr></table></figure>

<h1 id="移动-重命名-：mv"><a href="#移动-重命名-：mv" class="headerlink" title="移动(重命名)：mv"></a>移动(重命名)：mv</h1><blockquote>
<p>移动文件或修改文件名，根据第二参数类型（如目录，则移动文件；如为文件则重命令该文件）。</p>
<p>当第二个参数为目录时，第一个参数可以是多个以空格分隔的文件或目录，然后移动第一个参数指定的多个文件到第二个参数指定的目录中。</p>
</blockquote>
<h2 id="命令格式-4"><a href="#命令格式-4" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> [文件(目录)] [文件(目录)]</span><br></pre></td></tr></table></figure>

<h2 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h2><ul>
<li><strong>-i</strong>    :是否询问覆盖</li>
</ul>
<h2 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h2><p>将文件 test.log 重命名为 test1.txt</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> test.log test1.txt</span><br></pre></td></tr></table></figure>

<p>将文件 log1.txt,log2.txt,log3.txt 移动到根的 test3 目录中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> llog1.txt log2.txt log3.txt /test3</span><br></pre></td></tr></table></figure>

<p>将文件 file1 改名为 file2，如果 file2 已经存在，则询问是否覆盖</p>
<blockquote>
<p>不加参数-i则强制覆盖</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> -i log1.txt log2.txt</span><br></pre></td></tr></table></figure>

<p>移动当前文件夹下的所有文件到上一级目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> * ../</span><br></pre></td></tr></table></figure>

<h1 id="文件-目录-查找：find"><a href="#文件-目录-查找：find" class="headerlink" title="文件(目录)查找：find"></a>文件(目录)查找：find</h1><blockquote>
<p>Linux find 命令用来在指定目录下查找文件。任何位于<strong>参数之前</strong>的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p>
</blockquote>
<h2 id="命令格式-5"><a href="#命令格式-5" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find   [path]   [-option]  [-expression]</span><br></pre></td></tr></table></figure>

<h2 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h2><blockquote>
<p>find 根据下列规则判断 path 和 expression，在命令列上第一个 -option 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。</p>
</blockquote>
<ul>
<li><p>-amin n : 在过去 n 分钟内被读取过</p>
</li>
<li><p>-atime n : 在过去 n 天内被读取过的文件</p>
</li>
<li><p>-cmin n : 在过去 n 分钟内被修改过</p>
</li>
<li><p>-mtime n : 在过去 n 天内修改过的文件</p>
</li>
<li><p>-ctime n : 在过去 n 天内创建的文件</p>
</li>
<li><p>-name [name] : 文件名称符合 [name] 的文件</p>
</li>
<li><p>-iname [name] : 文件名称符合 [name] 的文件iname 会忽略大小写</p>
</li>
<li><p>-type [type] : 文件类型是 [type] 的文件</p>
<ul>
<li><p>c 类型的文件。</p>
</li>
<li><p>d: 目录</p>
</li>
<li><p>f: 一般文件</p>
</li>
<li><p>l: 符号连结</p>
</li>
</ul>
</li>
</ul>
<h2 id="案例-5"><a href="#案例-5" class="headerlink" title="案例"></a>案例</h2><p>将当前目录及其子目录下所有文件后缀为 .c 的文件列出来:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -name <span class="string">&quot;*.c&quot;</span></span><br></pre></td></tr></table></figure>

<p>将当前目录及其子目录中的所有文件列出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f</span><br></pre></td></tr></table></figure>

<p>将当前目录及其子目录下所有最近 20 天内更新过的文件列出:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -ctime 20</span><br></pre></td></tr></table></figure>

<h1 id="内容查找命令：grep"><a href="#内容查找命令：grep" class="headerlink" title="内容查找命令：grep"></a>内容查找命令：grep</h1><blockquote>
<p>grep 命令用于查找文件里符合条件的字符串。</p>
<p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据。</p>
</blockquote>
<h2 id="命令格式-6"><a href="#命令格式-6" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep [范本样式] [参数] [path...]</span><br></pre></td></tr></table></figure>

<h2 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h2><ul>
<li><strong>-E</strong> 或 <strong>–extended-regexp</strong>: 将样式为延伸的正则表达式来使用。</li>
<li><strong>-i</strong> 或 <strong>–ignore-case</strong> : 忽略字符大小写的差别。</li>
<li><strong>-l</strong> 或 <strong>–file-with-matches</strong> : 列出文件内容符合指定的样式的文件名称。</li>
<li><strong>-L</strong> 或 <strong>–files-without-match</strong> : 列出文件内容不符合指定的样式的文件名称。</li>
<li><strong>-r 或 –recursive</strong> : 此参数的效果和指定”-d recurse”参数相同。</li>
<li><strong>-v</strong> 或 <strong>–invert-match</strong> : 显示不包含匹配文本的所有行。</li>
<li><strong>-x</strong> 或 <strong>–line-regexp</strong> : 只显示全行符合的行。</li>
</ul>
<h2 id="案例-6"><a href="#案例-6" class="headerlink" title="案例"></a>案例</h2><p>在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="built_in">test</span> *file </span><br></pre></td></tr></table></figure>

<p>以递归的方式查找符合条件的文件。例如，查找指定目录&#x2F;etc&#x2F;acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串”update”的文件，并打印出该字符串所在行的内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -r update /etc/acpi </span><br></pre></td></tr></table></figure>

<p>反向查找。前面各个例子是查找并打印出符合条件的行，通过”-v”参数可以打印出不符合条件行的内容。查找文件名中包含 test 的文件中不包含test 的行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -v <span class="built_in">test</span> *<span class="built_in">test</span>*</span><br></pre></td></tr></table></figure>

<h1 id="文本处理：awk"><a href="#文本处理：awk" class="headerlink" title="文本处理：awk"></a>文本处理：awk</h1><blockquote>
<p>AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。awk是一个强大的工具能处理多种应用场景，但最常用的情况是对一个文件安行进行分割提取。</p>
</blockquote>
<h2 id="命令格式-7"><a href="#命令格式-7" class="headerlink" title="命令格式"></a>命令格式</h2><blockquote>
<p>对file以空格或者Tab分割，提取第？个数值。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk [参数] <span class="string">&#x27;&#123;print $?,$?&#125;&#x27;</span> [file]</span><br></pre></td></tr></table></figure>

<h2 id="参数-6"><a href="#参数-6" class="headerlink" title="参数"></a>参数</h2><ul>
<li>-F ： 指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。</li>
</ul>
<h2 id="案例-7"><a href="#案例-7" class="headerlink" title="案例"></a>案例</h2><p>行匹配语句 awk ‘’ 只能用单引号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;[pattern] action&#125;&#x27;</span> &#123;filenames&#125; </span><br></pre></td></tr></table></figure>

<p>每行按空格或TAB分割，输出文本中的1、4项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;print $1,$4&#125;&#x27;</span> log.txt</span><br></pre></td></tr></table></figure>

<p> 使用”,”分割</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -F, <span class="string">&#x27;&#123;print $1,$2&#125;&#x27;</span>   log.txt</span><br></pre></td></tr></table></figure>

<p>使用多个分隔符.先使用空格分割，然后对分割结果再使用”,”分割</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -F <span class="string">&#x27;[ ,]&#x27;</span>  <span class="string">&#x27;&#123;print $1,$2,$5&#125;&#x27;</span>   log.txt</span><br></pre></td></tr></table></figure>

<h1 id="管道符："><a href="#管道符：" class="headerlink" title="管道符：|"></a>管道符：|</h1><blockquote>
<p>管道符的作用是将上一个命令的输出转为下一个命令的输入，通过使用|（管道）符号，我们能重定向<strong>stdout</strong>流。管道符通常与grep、awk、find连用。</p>
</blockquote>
<h2 id="命令格式-8"><a href="#命令格式-8" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[命令] | [命令]</span><br></pre></td></tr></table></figure>

<h2 id="案例-8"><a href="#案例-8" class="headerlink" title="案例"></a>案例</h2><p>查找 xset q 命令 包含Caps Lock的行 并提取以空格或Tab分割的第4个元素</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xset q | grep <span class="string">&#x27;Caps Lock&#x27;</span> | awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="参数传递过滤：xargs"><a href="#参数传递过滤：xargs" class="headerlink" title="参数传递过滤：xargs"></a>参数传递过滤：xargs</h1><blockquote>
<p>xargs（英文全拼： eXtended ARGuments）是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。</p>
<p>xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。</p>
<p>xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。</p>
<p>xargs 默认的命令是 echo，这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。</p>
<p>xargs 是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令。</p>
<p>之所以能用到这个命令，关键是由于很多命令不支持|管道来传递参数，而日常工作中有有这个必要，所以就有了 xargs 命令。</p>
</blockquote>
<h2 id="命令格式-9"><a href="#命令格式-9" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">function</span>] | xargs [参数] [<span class="keyword">function</span>]</span><br></pre></td></tr></table></figure>

<h2 id="参数-7"><a href="#参数-7" class="headerlink" title="参数"></a>参数</h2><ul>
<li>-n num 后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。</li>
<li>-d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符。</li>
</ul>
<h2 id="案例-9"><a href="#案例-9" class="headerlink" title="案例"></a>案例</h2><p>-n 选项多行输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> test.txt</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">a b c d e f g</span><br><span class="line">h i j k l m n</span><br><span class="line">o p q</span><br><span class="line">r s t</span><br><span class="line">u v w x y z</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> test.txt | xargs</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> test.txt | xargs -n3</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">a b c</span><br><span class="line">d e f</span><br><span class="line">g h i</span><br><span class="line">j k l</span><br><span class="line">m n o</span><br><span class="line">p q r</span><br><span class="line">s t u</span><br><span class="line">v w x</span><br><span class="line">y z</span><br></pre></td></tr></table></figure>

<p>-d 选项可以自定义一个定界符</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;nameXnameXnameXname&quot;</span> | xargs -dX</span><br><span class="line"></span><br><span class="line">Otuput:</span><br><span class="line">name name name name</span><br></pre></td></tr></table></figure>

<p>xargs 的一个选项 -I，使用 -I 指定一个替换字符串 {}，这个字符串在 xargs 扩展时会被替换掉，当 -I 与 xargs 结合使用，每一个参数命令都会被执行一次</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#sk.sh命令内容，打印出所有参数。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> $*</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> arg.txt</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> arg.txt | xargs -I &#123;&#125; ./sk.sh -p &#123;&#125; -l</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">-p aaa -l</span><br><span class="line">-p bbb -l</span><br><span class="line">-p ccc -l</span><br></pre></td></tr></table></figure>

<p>假如你有一个文件包含了很多你希望下载的 URL，你能够使用 xargs下载所有链接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> url_list.txt | xargs wget -c</span><br></pre></td></tr></table></figure>

<h1 id="压缩解压：tar"><a href="#压缩解压：tar" class="headerlink" title="压缩解压：tar"></a>压缩解压：tar</h1><h2 id="命令格式-10"><a href="#命令格式-10" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar [参数]</span><br></pre></td></tr></table></figure>

<h2 id="参数-8"><a href="#参数-8" class="headerlink" title="参数"></a>参数</h2><ul>
<li>-A或–catenate 新增文件到已存在的备份文件。</li>
<li>-b&lt;区块数目&gt;或–blocking-factor&#x3D;&lt;区块数目&gt; 设置每笔记录的区块数目，每个区块大小为12Bytes。</li>
<li>-B或–read-full-records 读取数据时重设区块大小。</li>
<li>-c或–create 建立新的备份文件。</li>
<li>-C&lt;目的目录&gt;或–directory&#x3D;&lt;目的目录&gt; 切换到指定的目录。</li>
<li>-d或–diff或–compare 对比备份文件内和文件系统上的文件的差异。</li>
<li>-f&lt;备份文件&gt;或–file&#x3D;&lt;备份文件&gt; 指定备份文件。</li>
<li>-F&lt;Script文件&gt;或–info-script&#x3D;&lt;Script文件&gt; 每次更换磁带时，就执行指定的Script文件。</li>
<li>-g或–listed-incremental 处理GNU格式的大量备份。</li>
<li>-G或–incremental 处理旧的GNU格式的大量备份。</li>
<li>-h或–dereference 不建立符号连接，直接复制该连接所指向的原始文件。</li>
<li>-i或–ignore-zeros 忽略备份文件中的0 Byte区块，也就是EOF。</li>
<li>-k或–keep-old-files 解开备份文件时，不覆盖已有的文件。</li>
<li>-K&lt;文件&gt;或–starting-file&#x3D;&lt;文件&gt; 从指定的文件开始还原。</li>
<li>-l或–one-file-system 复制的文件或目录存放的文件系统，必须与tar指令执行时所处的文件系统相同，否则不予复制。</li>
<li>-L&lt;媒体容量&gt;或-tape-length&#x3D;&lt;媒体容量&gt; 设置存放每体的容量，单位以1024 Bytes计算。</li>
<li>-m或–modification-time 还原文件时，不变更文件的更改时间。</li>
<li>-M或–multi-volume 在建立，还原备份文件或列出其中的内容时，采用多卷册模式。</li>
<li>-N&lt;日期格式&gt;或–newer&#x3D;&lt;日期时间&gt; 只将较指定日期更新的文件保存到备份文件里。</li>
<li>-o或–old-archive或–portability 将资料写入备份文件时使用V7格式。</li>
<li>-O或–stdout 把从备份文件里还原的文件输出到标准输出设备。</li>
<li>-p或–same-permissions 用原来的文件权限还原文件。</li>
<li>-P或–absolute-names 文件名使用绝对名称，不移除文件名称前的”&#x2F;“号。</li>
<li>-r或–append 新增文件到已存在的备份文件的结尾部分。</li>
<li>-R或–block-number 列出每个信息在备份文件中的区块编号。</li>
<li>-s或–same-order 还原文件的顺序和备份文件内的存放顺序相同。</li>
<li>-S或–sparse 倘若一个文件内含大量的连续0字节，则将此文件存成稀疏文件。</li>
<li>-t或–list 列出备份文件的内容。</li>
<li>-T&lt;范本文件&gt;或–files-from&#x3D;&lt;范本文件&gt; 指定范本文件，其内含有一个或多个范本样式，让tar解开或建立符合设置条件的文件。</li>
<li>-u或–update 仅置换较备份文件内的文件更新的文件。</li>
<li>-U或–unlink-first 解开压缩文件还原文件之前，先解除文件的连接。</li>
<li>-v或–verbose 显示指令执行过程。</li>
<li>-V&lt;卷册名称&gt;或–label&#x3D;&lt;卷册名称&gt; 建立使用指定的卷册名称的备份文件。</li>
<li>-w或–interactive 遭遇问题时先询问用户。</li>
<li>-W或–verify 写入备份文件后，确认文件正确无误。</li>
<li>-x或–extract或–get 从备份文件中还原文件。</li>
<li>-X&lt;范本文件&gt;或–exclude-from&#x3D;&lt;范本文件&gt; 指定范本文件，其内含有一个或多个范本样式，让ar排除符合设置条件的文件。</li>
<li>-z或–gzip或–ungzip 通过gzip指令处理备份文件。</li>
<li>-Z或–compress或–uncompress 通过compress指令处理备份文</li>
</ul>
<h2 id="案例-10"><a href="#案例-10" class="headerlink" title="案例"></a>案例</h2><p>压缩文件 非打包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -czvf test.tar.gz a.c   //压缩 a.c文件为test.tar.gz</span><br></pre></td></tr></table></figure>

<p>列出压缩文件内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -tzvf test.tar.gz </span><br></pre></td></tr></table></figure>

<p>解压文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xzvf test.tar.gz </span><br></pre></td></tr></table></figure>

<p>解压文件到&#x2F;opt</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xzvf test.tar.gz -C /opt</span><br></pre></td></tr></table></figure>

<p>排除目录中的某些文件，然后进行压缩</p>
<blockquote>
<p>将文件 abc 进行压缩时，排除1.txt，压缩后的文件名为 abc.tar.gz</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar --exclude=abc/1.txt -zcvf abc.tar.gz abc</span><br></pre></td></tr></table></figure>

<h1 id="查看文件命令-1：cat"><a href="#查看文件命令-1：cat" class="headerlink" title="查看文件命令-1：cat"></a>查看文件命令-1：cat</h1><blockquote>
<p>直接查阅一个文件的内容可以使用cat命令。全称：concatenate</p>
</blockquote>
<h2 id="命令格式-11"><a href="#命令格式-11" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> [参数] filename</span><br></pre></td></tr></table></figure>

<h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><ul>
<li>-n：打印行号，连同空白行也会有行号</li>
<li>-E：将结尾回车字符用$显示</li>
<li>-T：将[Tab]以^I显示出来</li>
<li>-v：显示一些看不到的字符，如空格</li>
<li>-A：相当于-E 、-T、-v参数的整合</li>
</ul>
<h2 id="案例-11"><a href="#案例-11" class="headerlink" title="案例"></a>案例</h2><p>查看test.txt文件的内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> test.txt</span><br></pre></td></tr></table></figure>

<h1 id="查看文件命令-2：tac"><a href="#查看文件命令-2：tac" class="headerlink" title="查看文件命令-2：tac"></a>查看文件命令-2：tac</h1><blockquote>
<p>cat命令的反向命令，从文件尾部开始输出显示</p>
</blockquote>
<h2 id="常用参数-1"><a href="#常用参数-1" class="headerlink" title="常用参数"></a>常用参数</h2><ul>
<li>-n：打印行号，连同空白行也会有行号</li>
<li>-E：将结尾回车字符用$显示</li>
<li>-T：将[Tab]以^I显示出来</li>
<li>-v：显示一些看不到的字符，如空格</li>
<li>-A：相当于-E 、-T、-v参数的整合</li>
</ul>
<h2 id="案例-12"><a href="#案例-12" class="headerlink" title="案例"></a>案例</h2><p>查看test.txt文件的内容,从尾部查看。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tac</span> test.txt</span><br></pre></td></tr></table></figure>

<h1 id="查看文件命令-3：head"><a href="#查看文件命令-3：head" class="headerlink" title="查看文件命令-3：head"></a>查看文件命令-3：head</h1><blockquote>
<p>输出文件的头开始的n行。</p>
</blockquote>
<h2 id="命令格式-12"><a href="#命令格式-12" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">head</span> [-n number] filename</span><br></pre></td></tr></table></figure>

<h2 id="常用参数-2"><a href="#常用参数-2" class="headerlink" title="常用参数"></a>常用参数</h2><ul>
<li>-n：显示从文件头开始的第n行</li>
</ul>
<h2 id="案例-13"><a href="#案例-13" class="headerlink" title="案例"></a>案例</h2><p>查看test.txt文件的内容,从头开始的第20行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">head</span> -n 20 test.txt</span><br></pre></td></tr></table></figure>

<p>查看test.txt文件的内容,后100行都不打印只打印100行之前的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">head</span> -n -100 test.txt</span><br></pre></td></tr></table></figure>

<h1 id="查看文件命令-4：tail"><a href="#查看文件命令-4：tail" class="headerlink" title="查看文件命令-4：tail"></a>查看文件命令-4：tail</h1><blockquote>
<p>打印文件后面几行</p>
</blockquote>
<h2 id="命令格式-13"><a href="#命令格式-13" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span> [-n number] filename</span><br></pre></td></tr></table></figure>

<h2 id="常用参数-3"><a href="#常用参数-3" class="headerlink" title="常用参数"></a>常用参数</h2><ul>
<li>-n：显示从文件头开始的第n行</li>
</ul>
<h2 id="案例-14"><a href="#案例-14" class="headerlink" title="案例"></a>案例</h2><p>查看test.txt文件的内容,从尾部开始的第20行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span> -n 20 test.txt</span><br></pre></td></tr></table></figure>

<p>查看test.txt文件的内容,只打印100行后的数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span> -n +100 test.txt</span><br></pre></td></tr></table></figure>

<h1 id="查看文件命令-5：less"><a href="#查看文件命令-5：less" class="headerlink" title="查看文件命令-5：less"></a>查看文件命令-5：less</h1><blockquote>
<p>查看文件，一页一页的翻动。</p>
</blockquote>
<h2 id="命令格式-14"><a href="#命令格式-14" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">less filename</span><br></pre></td></tr></table></figure>

<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ul>
<li>空格：向下翻动一页</li>
<li>[pageup]：向上翻动一页</li>
<li>[pagedowm]：向下翻动一页</li>
<li>&#x2F;：向下查找文件</li>
<li>?：向上查找文件</li>
<li>n：向下搜索重复词（与搜索联动）</li>
<li>N：向上搜索重复词（与搜索联动）</li>
<li>g：去到第一行</li>
<li>G：去到最后一行</li>
<li>q：退出</li>
</ul>
]]></content>
      <categories>
        <category>IT知识</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux开启ssh服务</title>
    <url>/Linux%E5%BC%80%E5%90%AFssh%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>    Linux开启ssh服务，用以远程连接。</p>
<span id="more"></span>

<h1 id="安装SSH服务"><a href="#安装SSH服务" class="headerlink" title="安装SSH服务"></a>安装SSH服务</h1><p>Debian系统——apt包管理器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ssh</span><br></pre></td></tr></table></figure>

<p>Centos系统——yum包管理器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install openssh</span><br></pre></td></tr></table></figure>

<p>Archlinux系统——yay包管理器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S openssh</span><br></pre></td></tr></table></figure>

<h1 id="启动SSH服务"><a href="#启动SSH服务" class="headerlink" title="启动SSH服务"></a>启动SSH服务</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start sshd.service</span><br></pre></td></tr></table></figure>

<h1 id="开机自启SSH服务"><a href="#开机自启SSH服务" class="headerlink" title="开机自启SSH服务"></a>开机自启SSH服务</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> sshd.service</span><br></pre></td></tr></table></figure>

<h1 id="重启SSH服务"><a href="#重启SSH服务" class="headerlink" title="重启SSH服务"></a>重启SSH服务</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart sshd.service</span><br></pre></td></tr></table></figure>

<h1 id="关闭SSH服务"><a href="#关闭SSH服务" class="headerlink" title="关闭SSH服务"></a>关闭SSH服务</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop sshd.service</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>IT知识</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Manjaro-KDE环境下安装配置dwm环境</title>
    <url>/Manjaro-KDE%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEdwm%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>    在Manjaro系统的KDE桌面下安装配置dwm环境，包括dwm安装配置，picom安装配置，rofi安装配置，dunst安装配置。</p>
<span id="more"></span>

<h1 id="dwm的安装运行"><a href="#dwm的安装运行" class="headerlink" title="dwm的安装运行"></a>dwm的安装运行</h1><h2 id="从官网下载安装"><a href="#从官网下载安装" class="headerlink" title="从官网下载安装"></a>从官网下载安装</h2><blockquote>
<p><a href="https://dl.suckless.org/dwm/">dwm官网下载网址</a></p>
<p>可以选择任意历史版本，这里选择最新的dwm-6.3</p>
</blockquote>
<p>下载命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://dl.suckless.org/dwm/dwm-6.3.tar.gz</span><br></pre></td></tr></table></figure>

<p>解压dwm</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf dwm-6.3.tar.gz</span><br></pre></td></tr></table></figure>

<p>编译安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">sudo make clean install</span><br></pre></td></tr></table></figure>

<p>在登录界面添加dwm启动项</p>
<blockquote>
<p>进入存放文件的目录</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/share/xsessions</span><br></pre></td></tr></table></figure>

<blockquote>
<p>添加dwm启动项</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim dwm.desktop</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Encoding=UTF-8</span><br><span class="line">Name=Dwm</span><br><span class="line">Comment=Dynamic window manager</span><br><span class="line">Exec=/home/luo/dwm/dwm    <span class="comment">#此处填写的是解压的dwm目录下的dwm</span></span><br><span class="line">Icon=dwm</span><br><span class="line">Type=XSession</span><br></pre></td></tr></table></figure>

<h2 id="从AUR安装"><a href="#从AUR安装" class="headerlink" title="从AUR安装"></a>从AUR安装</h2><p>下载安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S dwm</span><br></pre></td></tr></table></figure>

<p>dwm源文件存放位置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.cache/yay/dwm</span><br></pre></td></tr></table></figure>

<p>如果需要对dwm进行个性化配置需要对目录下的dwm-6.3.tar.gz进行解压重新编译安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf dwm-6.3.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="运行dwm"><a href="#运行dwm" class="headerlink" title="运行dwm"></a>运行dwm</h2><blockquote>
<p>如果填写了dwm.desktop就会出现以下选项</p>
</blockquote>
<p>在用户登录界面选择dwm</p>
<p><img src="/Manjaro-KDE%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEdwm%E7%8E%AF%E5%A2%83/2022-09-29-08-36-49-image.png"></p>
<p><img src="/Manjaro-KDE%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEdwm%E7%8E%AF%E5%A2%83/2022-09-29-08-37-46-image.png"></p>
<p>选择完成后输入密码进行登录即可</p>
<p><img src="/Manjaro-KDE%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEdwm%E7%8E%AF%E5%A2%83/2022-09-29-08-38-27-image.png"></p>
<p>登录后效果</p>
<p><img src="/Manjaro-KDE%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEdwm%E7%8E%AF%E5%A2%83/2022-09-29-08-39-05-image.png"></p>
<h1 id="picom安装配置"><a href="#picom安装配置" class="headerlink" title="picom安装配置"></a>picom安装配置</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Git大神的版本"><a href="#Git大神的版本" class="headerlink" title="Git大神的版本"></a>Git大神的版本</h3><blockquote>
<p>大神博客连接：<a href="https://yaocc.cc/2022/06/19/linux%E4%B8%9D%E6%BB%91%E7%9A%84%E5%8A%A8%E7%94%BB%E4%BD%93%E9%AA%8C%E2%80%94%E2%80%94picom/">linux丝滑的动画体验 - cc</a></p>
</blockquote>
<p>下载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:yaocccc/picom.git</span><br></pre></td></tr></table></figure>

<p>编译安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> picom</span><br><span class="line">git checkout implement-window-animations</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf build</span><br><span class="line">LDFLAGS=<span class="string">&quot;-L/usr/local/lib&quot;</span> CPPFLAGS=<span class="string">&quot;-I/usr/local/include&quot;</span> meson --buildtype=release . build</span><br><span class="line">ninja -C build</span><br><span class="line">sudo ninja -C build install</span><br></pre></td></tr></table></figure>

<h3 id="安装官方版本"><a href="#安装官方版本" class="headerlink" title="安装官方版本"></a>安装官方版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S picom</span><br></pre></td></tr></table></figure>

<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><blockquote>
<p>这个文件是我个人从别处东拼西凑出来的，肯定是有不少问题的，仅供参考。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#################################</span></span><br><span class="line"><span class="comment">#           Animations         #</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># !These animations WILL NOT work correctly for any other wm other than phyOS-dwm fork!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fly-in: Windows fly in from random directions to the screen</span></span><br><span class="line"><span class="comment"># maximize: Windows pop from center of the screen to their respective positions</span></span><br><span class="line"><span class="comment"># minimize: Windows minimize from their position to the center of the screen</span></span><br><span class="line"><span class="comment"># slide-in-center: Windows move from upper-center of the screen to their respective positions</span></span><br><span class="line"><span class="comment"># slide-out-center: Windows move to the upper-center of the screen</span></span><br><span class="line"><span class="comment"># slide-left: Windows are created from the right-most window position and slide leftwards</span></span><br><span class="line"><span class="comment"># slide right: Windows are created from the left-most window position and slide rightwards</span></span><br><span class="line"><span class="comment"># slide-down: Windows are moved from the top of the screen and slide downward</span></span><br><span class="line"><span class="comment"># slide-up: Windows are moved from their position to top of the screen</span></span><br><span class="line"><span class="comment"># squeeze: Windows are either closed or created to/from their center y-position (the animation is similar to a blinking eye)</span></span><br><span class="line"><span class="comment"># squeeze-bottom: Similar to squeeze, but the animation starts from bottom-most y-position</span></span><br><span class="line"><span class="comment"># zoom: Windows are either created or destroyed from/to their center (not the screen center)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#enable or disable animations</span></span><br><span class="line">animations = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">#change animation speed of windows in current tag e.g open window in current tag</span></span><br><span class="line">animation-stiffness-in-tag = 125;</span><br><span class="line"><span class="comment">#change animation speed of windows when tag changes</span></span><br><span class="line">animation-stiffness-tag-change = 90.0;</span><br><span class="line"></span><br><span class="line">animation-window-mass = 0.4;</span><br><span class="line">animation-dampening = 15;</span><br><span class="line">animation-clamping = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#open windows</span></span><br><span class="line">animation-for-open-window = <span class="string">&quot;zoom&quot;</span>;</span><br><span class="line"><span class="comment">#minimize or close windows</span></span><br><span class="line">animation-for-unmap-window = <span class="string">&quot;squeeze&quot;</span>;</span><br><span class="line"><span class="comment">#popup windows</span></span><br><span class="line">animation-for-transient-window = <span class="string">&quot;slide-up&quot;</span>; <span class="comment">#available options: slide-up, slide-down, slide-left, slide-right, squeeze, squeeze-bottom, zoom</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#set animation for windows being transitioned out while changings tags</span></span><br><span class="line">animation-for-prev-tag = <span class="string">&quot;minimize&quot;</span>;</span><br><span class="line"><span class="comment">#enables fading for windows being transitioned out while changings tags</span></span><br><span class="line">enable-fading-prev-tag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#set animation for windows being transitioned in while changings tags</span></span><br><span class="line">animation-for-next-tag = <span class="string">&quot;slide-in-center&quot;</span>;</span><br><span class="line"><span class="comment">#enables fading for windows being transitioned in while changings tags</span></span><br><span class="line">enable-fading-next-tag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#################################</span></span><br><span class="line"><span class="comment">#           Fading              #</span></span><br><span class="line"><span class="comment">#################################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fade windows in/out when opening/closing and when opacity changes,</span></span><br><span class="line"><span class="comment">#  unless no-fading-openclose is used.</span></span><br><span class="line">fading = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Opacity change between steps while fading in. (0.01 - 1.0, defaults to 0.028)</span></span><br><span class="line"><span class="comment"># fade-in-step = 0.028</span></span><br><span class="line">fade-in-step = 0.023;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Opacity change between steps while fading out. (0.01 - 1.0, defaults to 0.03)</span></span><br><span class="line"><span class="comment"># fade-out-step = 0.03</span></span><br><span class="line">fade-out-step = 0.035;</span><br><span class="line"></span><br><span class="line"><span class="comment"># The time between steps in fade step, in milliseconds. (&gt; 0, defaults to 10)</span></span><br><span class="line">fade-delta = 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify a list of conditions of windows that should not be faded.</span></span><br><span class="line"><span class="comment"># fade-exclude = []</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Do not fade on window open/close.</span></span><br><span class="line"><span class="comment"># no-fading-openclose = false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Do not fade destroyed ARGB windows with WM frame. Workaround of bugs in Openbox, Fluxbox, etc.</span></span><br><span class="line"><span class="comment"># no-fading-destroyed-argb = false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#################################</span></span><br><span class="line"><span class="comment">#       General Settings        #</span></span><br><span class="line"><span class="comment">#################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Daemonize process. Fork to background after initialization. Causes issues with certain (badly-written) drivers.</span></span><br><span class="line"><span class="comment"># daemon = false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify the backend to use: `xrender`, `glx`, or `xr_glx_hybrid`.</span></span><br><span class="line"><span class="comment"># `xrender` is the default one.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># backend = &quot;glx&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable/disable VSync.</span></span><br><span class="line"><span class="comment"># vsync = true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable remote control via D-Bus. See the *D-BUS API* section below for more details.</span></span><br><span class="line"><span class="comment"># dbus = false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Try to detect WM windows (a non-override-redirect window with no</span></span><br><span class="line"><span class="comment"># child that has &#x27;WM_STATE&#x27;) and mark them as active.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># mark-wmwin-focused = false</span></span><br><span class="line">mark-wmwin-focused = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mark override-redirect windows that doesn&#x27;t have a child window with &#x27;WM_STATE&#x27; focused.</span></span><br><span class="line"><span class="comment"># mark-ovredir-focused = false</span></span><br><span class="line">mark-ovredir-focused = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Try to detect windows with rounded corners and don&#x27;t consider them</span></span><br><span class="line"><span class="comment"># shaped windows. The accuracy is not very high, unfortunately.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># detect-rounded-corners = false</span></span><br><span class="line">detect-rounded-corners = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Detect &#x27;_NET_WM_WINDOW_OPACITY&#x27; on client windows, useful for window managers</span></span><br><span class="line"><span class="comment"># not passing &#x27;_NET_WM_WINDOW_OPACITY&#x27; of client windows to frame windows.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># detect-client-opacity = false</span></span><br><span class="line">detect-client-opacity = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use EWMH &#x27;_NET_ACTIVE_WINDOW&#x27; to determine currently focused window,</span></span><br><span class="line"><span class="comment"># rather than listening to &#x27;FocusIn&#x27;/&#x27;FocusOut&#x27; event. Might have more accuracy,</span></span><br><span class="line"><span class="comment"># provided that the WM supports it.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">use-ewmh-active-win = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Unredirect all windows if a full-screen opaque window is detected,</span></span><br><span class="line"><span class="comment"># to maximize performance for full-screen windows. Known to cause flickering</span></span><br><span class="line"><span class="comment"># when redirecting/unredirecting windows.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">unredir-if-possible = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Delay before unredirecting the window, in milliseconds. Defaults to 0.</span></span><br><span class="line"><span class="comment"># unredir-if-possible-delay = 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Conditions of windows that shouldn&#x27;t be considered full-screen for unredirecting screen.</span></span><br><span class="line"><span class="comment"># unredir-if-possible-exclude = []</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use &#x27;WM_TRANSIENT_FOR&#x27; to group windows, and consider windows</span></span><br><span class="line"><span class="comment"># in the same group focused at the same time.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># detect-transient = false</span></span><br><span class="line">detect-transient = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use &#x27;WM_CLIENT_LEADER&#x27; to group windows, and consider windows in the same</span></span><br><span class="line"><span class="comment"># group focused at the same time. This usually means windows from the same application</span></span><br><span class="line"><span class="comment"># will be considered focused or unfocused at the same time.</span></span><br><span class="line"><span class="comment"># &#x27;WM_TRANSIENT_FOR&#x27; has higher priority if detect-transient is enabled, too.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># detect-client-leader = false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Resize damaged region by a specific number of pixels.</span></span><br><span class="line"><span class="comment"># A positive value enlarges it while a negative one shrinks it.</span></span><br><span class="line"><span class="comment"># If the value is positive, those additional pixels will not be actually painted</span></span><br><span class="line"><span class="comment"># to screen, only used in blur calculation, and such. (Due to technical limitations,</span></span><br><span class="line"><span class="comment"># with use-damage, those pixels will still be incorrectly painted to screen.)</span></span><br><span class="line"><span class="comment"># Primarily used to fix the line corruption issues of blur,</span></span><br><span class="line"><span class="comment"># in which case you should use the blur radius value here</span></span><br><span class="line"><span class="comment"># (e.g. with a 3x3 kernel, you should use `--resize-damage 1`,</span></span><br><span class="line"><span class="comment"># with a 5x5 one you use `--resize-damage 2`, and so on).</span></span><br><span class="line"><span class="comment"># May or may not work with *--glx-no-stencil*. Shrinking doesn&#x27;t function correctly.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># resize-damage = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify a list of conditions of windows that should be painted with inverted color.</span></span><br><span class="line"><span class="comment"># Resource-hogging, and is not well tested.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># invert-color-include = []</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># GLX backend: Avoid using stencil buffer, useful if you don&#x27;t have a stencil buffer.</span></span><br><span class="line"><span class="comment"># Might cause incorrect opacity when rendering transparent content (but never</span></span><br><span class="line"><span class="comment"># practically happened) and may not work with blur-background.</span></span><br><span class="line"><span class="comment"># My tests show a 15% performance boost. Recommended.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">glx-no-stencil = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># GLX backend: Avoid rebinding pixmap on window damage.</span></span><br><span class="line"><span class="comment"># Probably could improve performance on rapid window content changes,</span></span><br><span class="line"><span class="comment"># but is known to break things on some drivers (LLVMpipe, xf86-video-intel, etc.).</span></span><br><span class="line"><span class="comment"># Recommended if it works.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># glx-no-rebind-pixmap = false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Disable the use of damage information.</span></span><br><span class="line"><span class="comment"># This cause the whole screen to be redrawn everytime, instead of the part of the screen</span></span><br><span class="line"><span class="comment"># has actually changed. Potentially degrades the performance, but might fix some artifacts.</span></span><br><span class="line"><span class="comment"># The opposing option is use-damage</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># no-use-damage = false</span></span><br><span class="line">use-damage = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use X Sync fence to sync clients&#x27; draw calls, to make sure all draw</span></span><br><span class="line"><span class="comment"># calls are finished before picom starts drawing. Needed on nvidia-drivers</span></span><br><span class="line"><span class="comment"># with GLX backend for some users.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">xrender-sync-fence = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># GLX backend: Use specified GLSL fragment shader for rendering window contents.</span></span><br><span class="line"><span class="comment"># See `compton-default-fshader-win.glsl` and `compton-fake-transparency-fshader-win.glsl`</span></span><br><span class="line"><span class="comment"># in the source tree for examples.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># glx-fshader-win = &quot;compton-fake-transparency-fshader-win.glsl&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Force all windows to be painted with blending. Useful if you</span></span><br><span class="line"><span class="comment"># have a glx-fshader-win that could turn opaque pixels transparent.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># force-win-blend = false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Do not use EWMH to detect fullscreen windows.</span></span><br><span class="line"><span class="comment"># Reverts to checking if a window is fullscreen based only on its size and coordinates.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># no-ewmh-fullscreen = false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Dimming bright windows so their brightness doesn&#x27;t exceed this set value.</span></span><br><span class="line"><span class="comment"># Brightness of a window is estimated by averaging all pixels in the window,</span></span><br><span class="line"><span class="comment"># so this could comes with a performance hit.</span></span><br><span class="line"><span class="comment"># Setting this to 1.0 disables this behaviour. Requires --use-damage to be disabled. (default: 1.0)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># max-brightness = 1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Make transparent windows clip other windows like non-transparent windows do,</span></span><br><span class="line"><span class="comment"># instead of blending on top of them.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">transparent-clipping = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the log level. Possible values are:</span></span><br><span class="line"><span class="comment">#  &quot;trace&quot;, &quot;debug&quot;, &quot;info&quot;, &quot;warn&quot;, &quot;error&quot;</span></span><br><span class="line"><span class="comment"># in increasing level of importance. Case doesn&#x27;t matter.</span></span><br><span class="line"><span class="comment"># If using the &quot;TRACE&quot; log level, it&#x27;s better to log into a file</span></span><br><span class="line"><span class="comment"># using *--log-file*, since it can generate a huge stream of logs.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># log-level = &quot;debug&quot;</span></span><br><span class="line">log-level = <span class="string">&quot;warn&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the log file.</span></span><br><span class="line"><span class="comment"># If *--log-file* is never specified, logs will be written to stderr.</span></span><br><span class="line"><span class="comment"># Otherwise, logs will to written to the given file, though some of the early</span></span><br><span class="line"><span class="comment"># logs might still be written to the stderr.</span></span><br><span class="line"><span class="comment"># When setting this option from the config file, it is recommended to use an absolute path.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># log-file = &quot;/path/to/your/log/file&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Show all X errors (for debugging)</span></span><br><span class="line"><span class="comment"># show-all-xerrors = false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Write process ID to a file.</span></span><br><span class="line"><span class="comment"># write-pid-path = &quot;/path/to/your/log/file&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Window type settings</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># &#x27;WINDOW_TYPE&#x27; is one of the 15 window types defined in EWMH standard:</span></span><br><span class="line"><span class="comment">#     &quot;unknown&quot;, &quot;desktop&quot;, &quot;dock&quot;, &quot;toolbar&quot;, &quot;menu&quot;, &quot;utility&quot;,</span></span><br><span class="line"><span class="comment">#     &quot;splash&quot;, &quot;dialog&quot;, &quot;normal&quot;, &quot;dropdown_menu&quot;, &quot;popup_menu&quot;,</span></span><br><span class="line"><span class="comment">#     &quot;tooltip&quot;, &quot;notification&quot;, &quot;combo&quot;, and &quot;dnd&quot;.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Following per window-type options are available: ::</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   fade, shadow:::</span></span><br><span class="line"><span class="comment">#     Controls window-type-specific shadow and fade settings.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   opacity:::</span></span><br><span class="line"><span class="comment">#     Controls default opacity of the window type.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   focus:::</span></span><br><span class="line"><span class="comment">#     Controls whether the window of this type is to be always considered focused.</span></span><br><span class="line"><span class="comment">#     (By default, all window types except &quot;normal&quot; and &quot;dialog&quot; has this on.)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   full-shadow:::</span></span><br><span class="line"><span class="comment">#     Controls whether shadow is drawn under the parts of the window that you</span></span><br><span class="line"><span class="comment">#     normally won&#x27;t be able to see. Useful when the window has parts of it</span></span><br><span class="line"><span class="comment">#     transparent, and you want shadows in those areas.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   clip-shadow-above:::</span></span><br><span class="line"><span class="comment">#     Controls wether shadows that would have been drawn above the window should</span></span><br><span class="line"><span class="comment">#     be clipped. Useful for dock windows that should have no shadow painted on top.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   redir-ignore:::</span></span><br><span class="line"><span class="comment">#     Controls whether this type of windows should cause screen to become</span></span><br><span class="line"><span class="comment">#     redirected again after been unredirected. If you have unredir-if-possible</span></span><br><span class="line"><span class="comment">#     set, and doesn&#x27;t want certain window to cause unnecessary screen redirection,</span></span><br><span class="line"><span class="comment">#     you can set this to `true`.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">wintypes:</span><br><span class="line">&#123;</span><br><span class="line">  tooltip = &#123; fade = <span class="literal">true</span>; shadow = <span class="literal">true</span>; opacity = 0.75; focus = <span class="literal">true</span>; full-shadow = <span class="literal">false</span>; &#125;;</span><br><span class="line">  dock = &#123; shadow = <span class="literal">false</span>; clip-shadow-above = <span class="literal">true</span>; &#125;</span><br><span class="line">  dnd = &#123; shadow = <span class="literal">false</span>; &#125;</span><br><span class="line">  popup_menu = &#123; opacity = 0.8; &#125;</span><br><span class="line">  dropdown_menu = &#123; opacity = 0.8; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">opacity-rule = [</span><br><span class="line">  <span class="string">&quot;100:class_g = &#x27;St&#x27; &amp;&amp; focused&quot;</span>,</span><br><span class="line">  <span class="string">&quot;50:class_g = &#x27;St&#x27; &amp;&amp; !focused&quot;</span>,</span><br><span class="line">  <span class="string">&quot;100:fullscreen&quot;</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基础设置</span></span><br><span class="line">backend = <span class="string">&quot;glx&quot;</span>;</span><br><span class="line">mark-wmwin-focused = <span class="literal">true</span>;</span><br><span class="line">mark-ovredir-focused = <span class="literal">true</span>;</span><br><span class="line">detect-client-opacity = <span class="literal">true</span>;</span><br><span class="line">unredir-if-possible = <span class="literal">true</span>;</span><br><span class="line">vsync = <span class="literal">true</span>;</span><br><span class="line">dbe = <span class="literal">false</span>;</span><br><span class="line">detect-transient = <span class="literal">true</span>;</span><br><span class="line">detect-client-leader = <span class="literal">true</span>;</span><br><span class="line">invert-color-include = [ ];</span><br><span class="line">glx-copy-from-front = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 圆角</span></span><br><span class="line">corner-radius = 10.0;</span><br><span class="line">round-borders = 2;</span><br><span class="line">rounded-corners-exclude = [</span><br><span class="line">    <span class="string">&quot;class_g *= &#x27;dwm&#x27;&quot;</span>,</span><br><span class="line">    <span class="comment"># &quot;class_g *= &#x27;fcitx&#x27;&quot;,</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透明</span></span><br><span class="line">active-opacity = 0.95;</span><br><span class="line">opacity-rule = [</span><br><span class="line">    <span class="string">&quot;80:class_g = &#x27;dwmsystray&#x27;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;100:class_g = &#x27;mpv&#x27;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;100:class_g = &#x27;org.remmina.Remmina&#x27;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;100:class_g = &#x27;Surf&#x27;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;100:class_g = &#x27;qutebrowser&#x27;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;100:name *? = &#x27;Sunflower&#x27;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;100:WM_NAME@:s *= &#x27;bilibili&#x27;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;100:class_g = &#x27;obs&#x27;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;100:class_g = &#x27;Gimp&#x27;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;100:WM_CLASS@:s *= &#x27;tim.exe&#x27;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;95:class_g = &#x27;Wine&#x27;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;100:class_g *= &#x27;crx_&#x27;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;100:WM_CLASS@:s *= &#x27;vncviewer&#x27;&quot;</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模糊</span></span><br><span class="line">blur-method = <span class="string">&quot;dual_kawase&quot;</span>;</span><br><span class="line">blur-strength = 3;</span><br><span class="line">blur-kern = <span class="string">&quot;3x3box&quot;</span>;</span><br><span class="line">blur-background-exclude = [</span><br><span class="line">    <span class="string">&quot;window_type = &#x27;dock&#x27;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;window_type = &#x27;desktop&#x27;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;_GTK_FRAME_EXTENTS@:c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;class_g *= &#x27;dwm&#x27;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name *? = &#x27;Sunflower&#x27;&quot;</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h2 id="运行picom命令"><a href="#运行picom命令" class="headerlink" title="运行picom命令"></a>运行picom命令</h2><blockquote>
<p>config指向配置文件</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">picom --experimental-backends --config ~/software/picom/picom.sample.conf</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>IT知识</category>
      </categories>
      <tags>
        <tag>技术知识</tag>
        <tag>Linux</tag>
        <tag>更新中</tag>
      </tags>
  </entry>
  <entry>
    <title>Manjaro-i3wm安装</title>
    <url>/Manjaro-i3wm%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>    详细介绍Manjaro系统的i3wm桌面环境的安装与踩坑。</p>
<span id="more"></span>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>manjaro i3其实是i3-gaps,i3wm的加强版,主要能使窗口间有间隔！而且下载完整版安装很多软件及配置，快捷键都默认设置好了  。<br>系统镜像在官网下载的社区版本manjaro+i3</p>
<h2 id="ISO镜像下载"><a href="#ISO镜像下载" class="headerlink" title="ISO镜像下载"></a>ISO镜像下载</h2><p><a href="https://manjaro.org/download/">下载网址</a>：<a href="https://manjaro.org/download/">https://manjaro.org/download/</a></p>
<p><img src="/Manjaro-i3wm%E5%AE%89%E8%A3%85/2022-08-13-21-01-55-image.png"></p>
<h2 id="刻录U盘"><a href="#刻录U盘" class="headerlink" title="刻录U盘"></a>刻录U盘</h2><h3 id="下载U盘刻录工具Rufus"><a href="#下载U盘刻录工具Rufus" class="headerlink" title="下载U盘刻录工具Rufus"></a>下载U盘刻录工具Rufus</h3><p><a href="https://rufus.en.softonic.com/">下载地址</a>：<a href="https://rufus.en.softonic.com/">https://rufus.en.softonic.com/</a></p>
<h3 id="Rufus使用"><a href="#Rufus使用" class="headerlink" title="Rufus使用"></a>Rufus使用</h3><h2 id="进入BIOS启动安装程序"><a href="#进入BIOS启动安装程序" class="headerlink" title="进入BIOS启动安装程序"></a>进入BIOS启动安装程序</h2><h2 id="安装Manjaro"><a href="#安装Manjaro" class="headerlink" title="安装Manjaro"></a>安装Manjaro</h2>]]></content>
      <categories>
        <category>IT知识</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL:三范式</title>
    <url>/SQL-%E4%B8%89%E8%8C%83%E5%BC%8F/</url>
    <content><![CDATA[<p>    SQL范式的作用是防止信息的重复、防止更新异常  、防止插入异常（如：无法正常显示信息）  、防止删除异常（如：删除了不因该的有用信息）</p>
<p>    SQL中有6大范式，但一般数据库只会使用到前三大范式。一般地，在进行数据库设计时，应遵循三大原则，也就是我们通常说的三大范式。</p>
<p><img src="https://img-blog.csdnimg.cn/20190414095710259.png" alt="关系"></p>
<span id="more"></span>

<h1 id="第一范式1NF"><a href="#第一范式1NF" class="headerlink" title="第一范式1NF"></a>第一范式1NF</h1><p><strong>定义：</strong> 强调的是列的原子性，即数据库中每一列的字段都是单一属性，不可再分的。并且这个单一属性必须是由基本的数据类型所构成的</p>
<p><strong>核心原则</strong>：属性不可切割</p>
<p><strong>举例</strong>：</p>
<p><img src="/SQL-%E4%B8%89%E8%8C%83%E5%BC%8F/2022-09-04-14-10-15-image.png"></p>
<p>    很明显上图所示的表格设计是不符合第一范式的，商品列中的数据不是原子数据项，是可以进行分割的，因此对表格进行修改，让表格符合第一范式的要求，修改结果如下图所示</p>
<p><img src="/SQL-%E4%B8%89%E8%8C%83%E5%BC%8F/2022-09-04-14-10-48-image.png"></p>
<h1 id="第二·范式2NF"><a href="#第二·范式2NF" class="headerlink" title="第二·范式2NF"></a>第二·范式2NF</h1><p><strong>定义</strong>：在满足1NF的基础上再满足依赖性的两个约束：一张表必须有一个主键；非主键类必须完全依赖于主键，而不能只依赖主键的一部分。</p>
<p><strong>核心原则</strong>：不能存在“部分函数依赖” </p>
<p><strong>举例</strong>：</p>
<p><img src="/SQL-%E4%B8%89%E8%8C%83%E5%BC%8F/2022-09-04-14-13-00-image.png"></p>
<p>    以上表格明显存在，部分依赖。比如，这张表的主键是 (学号，课名），分数确实完全依赖于 (学号，课名），但是姓名并不完全依赖于(学号，课名）。应修去掉部分函数依赖依赖修改为如下两个表。</p>
<p><img src="/SQL-%E4%B8%89%E8%8C%83%E5%BC%8F/2022-09-04-14-13-55-image.png">        <img src="/SQL-%E4%B8%89%E8%8C%83%E5%BC%8F/2022-09-04-14-14-00-image.png"></p>
<h1 id="第三范式3NF"><a href="#第三范式3NF" class="headerlink" title="第三范式3NF"></a>第三范式3NF</h1><p><strong>定义</strong>：在满足2NF的基础上，另外再满足一个条件：非主键列必须直接依赖于主键，不能存在传递依赖。</p>
<p><strong>核心原则</strong>：不能存在传递函数依赖</p>
<p><strong>举例</strong>：</p>
<p><img src="/SQL-%E4%B8%89%E8%8C%83%E5%BC%8F/2022-09-04-14-16-51-image.png"></p>
<p>    在这张表中，存在传递函数依赖：学号-&gt;系名-&gt;系主任。学号不能直接推出系主任。上面表需要再次拆解。</p>
<p><img src="/SQL-%E4%B8%89%E8%8C%83%E5%BC%8F/2022-09-04-14-19-01-image.png">        <img src="/SQL-%E4%B8%89%E8%8C%83%E5%BC%8F/2022-09-04-14-19-06-image.png"></p>
]]></content>
      <categories>
        <category>IT知识</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL:函数依赖</title>
    <url>/SQL-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<p>    函数依赖是指关系中属性间（或者说是表中字段间）的对应关系。函数依赖是SQL中的基础知识，理解了什么是函数依赖便能更好的理解什么是“范式”。</p>
<span id="more"></span>

<h1 id="完全函数依赖"><a href="#完全函数依赖" class="headerlink" title="完全函数依赖"></a>完全函数依赖</h1><blockquote>
<p>设X，Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全函数依赖于X</p>
</blockquote>
<p>解释：</p>
<p>    比如通过，(学号，课程) 推出分数 ，但是单独用学号推断不出来分数，那么就可以说：分数 完全依赖于(学号，课程) 。</p>
<p><img src="/SQL-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96/2022-09-01-00-11-46-image.png"></p>
<p>    即：通过AB能得出C，但是AB单独得不出C，那么说C完全依赖于AB。</p>
<p><img src="/SQL-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96/2022-09-01-00-00-54-image.png"></p>
<h1 id="部分函数依赖"><a href="#部分函数依赖" class="headerlink" title="部分函数依赖"></a>部分函数依赖</h1><blockquote>
<p>假如 Y函数依赖于 X，但同时 Y 并不完全函数依赖于 X，那么我们就称 Y 部分函数依赖于 X。</p>
</blockquote>
<p>解释：</p>
<p>    比如通过，(学号，课程) 推出姓名，因为其实直接可以通过，学号推出姓名，所以：姓名  部分依赖于 (学号，课程)</p>
<p><img src="/SQL-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96/2022-09-01-00-15-01-image.png"></p>
<p>    即：通过AB能得出C，通过A也能得出C，或者通过B也能得出C，那么说C部分依赖于AB。</p>
<p><img src="/SQL-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96/2022-08-31-23-58-38-image.png"></p>
<h1 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h1><blockquote>
<p>传递函数依赖：设X，Y，Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X。</p>
</blockquote>
<p>解释：</p>
<p>    比如：学号 推出 系名 ， 系名 推出 系主任， 但是，系主任推不出学号，系主任主要依赖于系名。这种情况可以说：系主任 传递依赖于 学号</p>
<p><img src="/SQL-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96/2022-09-01-00-16-03-image.png"></p>
<p>    即：通过A得到B，通过B得到C，但是C得不到A，那么说C传递依赖于A。</p>
<p><img src="/SQL-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96/2022-09-01-00-05-27-image.png"></p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>参考图表</p>
<p><img src="/SQL-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96/2022-08-31-23-51-25-image.png"></p>
]]></content>
      <categories>
        <category>IT知识</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL:分页（LIMIT）</title>
    <url>/SQL-%E5%88%86%E9%A1%B5/</url>
    <content><![CDATA[<p>    分页查询是客户端通过传递start(页码)，limit(每页显示的条数)两个参数去分页查询数据库表中的数据。其本质是通过MySQL库中的LIMIT函数，从表中提取连续的若干行。该函数的用法也不仅限于分页，我们可以根据我们的需求改写自己的分页语句。</p>
<span id="more"></span>

<h1 id="LIMIT函数说明"><a href="#LIMIT函数说明" class="headerlink" title="LIMIT函数说明"></a>LIMIT函数说明</h1><p>从索引_offset（第_offset+1条数据）开始查询_rows条数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> _table</span><br><span class="line">LIMIT [_offset], _rows</span><br></pre></td></tr></table></figure>

<ul>
<li><p>_table：表名</p>
</li>
<li><p>_offset：起始索引（从0开始）(可选项，默认为0)</p>
</li>
<li><p>_rows：需要查询的行数</p>
</li>
</ul>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ul>
<li><p>降低网络传输的数据量，降低带宽</p>
</li>
<li><p>提高查询效率</p>
</li>
</ul>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>分页公式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> _table</span><br><span class="line">LIMIT (page<span class="number">-1</span>)<span class="operator">*</span>pagesize,pagesize;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>page：第几页</p>
</li>
<li><p>pagesize：每页数据的条数</p>
</li>
</ul>
<h2 id="查询数据是否存在"><a href="#查询数据是否存在" class="headerlink" title="查询数据是否存在"></a>查询数据是否存在</h2><p>检查表中是否有满足某条件的数据，使用LIMIT提高效率。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查询是否有小于1990-01-01的日期。效率低，需要全表扫描。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> _table</span><br><span class="line"><span class="keyword">WHERE</span> _date <span class="operator">&lt;</span> <span class="string">&#x27;1990-01-01&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--只查询是否有第一条。效率高，找到立即停止。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> _table</span><br><span class="line"><span class="keyword">WHERE</span> _date <span class="operator">&lt;</span> <span class="string">&#x27;1990-01-01&#x27;</span></span><br><span class="line">LIMIT <span class="number">0</span>, <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="查询最大-最小-值"><a href="#查询最大-最小-值" class="headerlink" title="查询最大(最小)值"></a>查询最大(最小)值</h2><p>查询数据最大最小值其实只要一条数据，可以使用LIMIT提高效率。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> _table</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> _id <span class="keyword">DESC</span>    <span class="comment">--最大值</span></span><br><span class="line">LIMIT <span class="number">0</span>, <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>参考视频：<a href="https://www.bilibili.com/video/BV1fN4y1u7dP?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1fN4y1u7dP?spm_id_from=333.337.search-card.all.click</a></p>
<p>参考文章：<a href="https://blog.csdn.net/qq_43542074/article/details/101099589">sql如何实现分页_三宝鸭的博客-CSDN博客_sql分页</a></p>
]]></content>
      <categories>
        <category>IT知识</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>vim删除每行前后n个字符</title>
    <url>/vim%E5%88%A0%E9%99%A4%E6%AF%8F%E8%A1%8C%E5%89%8D%E5%90%8En%E4%B8%AA%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<p>​		使用vim删除（替换）指定行的行前或者行后的n个字符。</p>
<span id="more"></span>

<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="删除每行前10个字符"><a href="#删除每行前10个字符" class="headerlink" title="删除每行前10个字符"></a>删除每行前10个字符</h3><figure class="highlight v"><table><tr><td class="code"><pre><span class="line">:%s/^.\&#123;<span class="number">10\&#125;</span><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<h3 id="删除每行后10个字符"><a href="#删除每行后10个字符" class="headerlink" title="删除每行后10个字符"></a>删除每行后10个字符</h3><figure class="highlight v"><table><tr><td class="code"><pre><span class="line">:%s/.\&#123;<span class="number">10\&#125;</span>$<span class="comment">//</span></span><br></pre></td></tr></table></figure>

<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>%表示所有行，s表示替换，<code>%</code>可用<code>1,$</code>代替。</p>
<p>正则表达式<code>/^.\&#123;10\&#125;//</code>中，^表示行首，<code>.</code>表示要删除的字符个数，<code>.\&#123;10\&#125;</code>表示10个字符，可用10个<code>.</code>表示</p>
<p>正则表达式<code>/^.\&#123;10\&#125;//</code>整体意思为从行开头，到第10个字符。</p>
<p>正则表达式<code>/.\&#123;10\&#125;$//</code>中，$表示行首，</p>
<p>正则表达式<code>/.\&#123;10\&#125;$//</code>整体意思为从尾部开始开头，到第10个字符</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>这个删除命令用到的是vim的字符串替换命令，将指定字符替换成<code>空</code>。</p>
<p>vim编辑器替换命令：</p>
<figure class="highlight v"><table><tr><td class="code"><pre><span class="line">:%s/s1/s2/    用字符串s2替换每行的第一个字符串s1</span><br><span class="line">:%s/s1/s2/g   用字符串s2替换每行的所有字符串s1</span><br></pre></td></tr></table></figure>

<p>s1和s2中的特殊字符需要使用转义符号<code>\</code>，进行转义。</p>
]]></content>
      <categories>
        <category>IT知识</category>
      </categories>
      <tags>
        <tag>技术知识</tag>
        <tag>Linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>在CentOS中安装配置zsh</title>
    <url>/%E5%9C%A8CentOS%E4%B8%AD%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEzsh/</url>
    <content><![CDATA[<p>    在CentOS中使用zsh及其插件能够在工作中大提高效率，主要使用的插件有：</p>
<p>zsh-completions：命令补全插件。shell进行补全。<br>zsh-syntax-highlighting：高亮插件。对shell语法进行高亮展示。<br>zsh-autosuggestions：历史命令插件。对历史命令进行存储提示。</p>
<span id="more"></span>

<h1 id="安装基本组件"><a href="#安装基本组件" class="headerlink" title="安装基本组件"></a>安装基本组件</h1><h2 id="安装zsh和工具"><a href="#安装zsh和工具" class="headerlink" title="安装zsh和工具"></a>安装zsh和工具</h2><p>首先执行 <code>yum</code> 命令来安装需要的 <code>zsh</code> 原始程序与 <code>git</code> 程序来 <code>pull</code> 代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install -y zsh git wget vim</span><br></pre></td></tr></table></figure>

<h2 id="安装-oh-my-zsh脚本-这一步需要安装-wget"><a href="#安装-oh-my-zsh脚本-这一步需要安装-wget" class="headerlink" title="安装 oh my zsh脚本 (这一步需要安装 wget)"></a>安装 oh my zsh脚本 (这一步需要安装 <code>wget</code>)</h2><p>先把install.sh文件下载下来(这是gitee的国内镜像源)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh</span><br></pre></td></tr></table></figure>

<p>然后给install.sh添加权限 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x install.sh</span><br></pre></td></tr></table></figure>

<p>用vim打开install.sh发现，有的地方还是有clone github的代码，所以做如下修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Default settings</span></span><br><span class="line">ZSH=<span class="variable">$&#123;ZSH:-~/.oh-my-zsh&#125;</span></span><br><span class="line">REPO=<span class="variable">$&#123;REPO:-ohmyzsh/ohmyzsh&#125;</span></span><br><span class="line">REMOTE=<span class="variable">$&#123;REMOTE:-https://github.com/<span class="variable">$&#123;REPO&#125;</span>.git&#125;</span></span><br><span class="line">BRANCH=<span class="variable">$&#123;BRANCH:-master&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改为</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Default settings</span></span><br><span class="line">ZSH=<span class="variable">$&#123;ZSH:-~/.oh-my-zsh&#125;</span>    </span><br><span class="line">REPO=<span class="variable">$&#123;REPO:-mirrors/oh-my-zsh&#125;</span>    <span class="comment">#修改这一行</span></span><br><span class="line">REMOTE=<span class="variable">$&#123;REMOTE:-https://gitee.com/<span class="variable">$&#123;REPO&#125;</span>.git&#125;</span>    <span class="comment">#修改这一行</span></span><br><span class="line">BRANCH=<span class="variable">$&#123;BRANCH:-master&#125;</span></span><br></pre></td></tr></table></figure>

<p>完成后 <code>:wq!</code>保存,执行install.sh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh install.sh</span><br></pre></td></tr></table></figure>

<p>询问是否把<code>zsh</code>修改为默认shell时，选择否n</p>
<blockquote>
<p>在使用ssh时如果默认使用zsh会有些命令找不到，因此不建议使用默认shell为zsh</p>
</blockquote>
<p><img src="/%E5%9C%A8CentOS%E4%B8%AD%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEzsh/2022-09-09-14-56-06-image.png"></p>
<p>显示一下则完成安装</p>
<p><img src="/%E5%9C%A8CentOS%E4%B8%AD%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEzsh/2022-09-09-14-56-41-image.png"></p>
<h1 id="进行配置"><a href="#进行配置" class="headerlink" title="进行配置"></a>进行配置</h1><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>修改.zshrc文件里的<code>ZSH_THEME=&quot;robbyussell&quot;</code>为<code>ZSH_THEME=&quot;agnoster&quot;</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc </span><br></pre></td></tr></table></figure>

<p><img src="/%E5%9C%A8CentOS%E4%B8%AD%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEzsh/2022-09-09-15-01-01-image.png"></p>
<p>并通过 <code>source ~/.zshrc</code> 命令更新它们的配置文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>

<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>安装插件。插件位置在&#x2F;.oh-my-zsh&#x2F;custom&#x2F;plugins&#x2F;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitee.com/lightnear/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/yanzhongqian/zsh-autosuggestions.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/twd2606/zsh-completions.git <span class="variable">$&#123;ZSH_CUSTOM:=~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-completions</span><br></pre></td></tr></table></figure>

<p>修改配置文件使用插件生效</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vim</span> ~/.zshrc</span><br></pre></td></tr></table></figure>

<p>修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plugins=(git)</span><br></pre></td></tr></table></figure>

<p>修改为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">        git</span><br><span class="line">        zsh-syntax-highlighting</span><br><span class="line">        zsh-autosuggestions</span><br><span class="line">        zsh-completions</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img src="/%E5%9C%A8CentOS%E4%B8%AD%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEzsh/2022-09-09-15-23-46-image.png"></p>
<p>刷新生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure>

<h1 id="使用zsh"><a href="#使用zsh" class="headerlink" title="使用zsh"></a>使用zsh</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zsh</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>参考文章：<a href="https://blog.csdn.net/qimowei/article/details/119517167">Centos7-Linux安装zsh和oh-my-zsh(内含国内安装方法)_水豚少年的码农生活的博客-CSDN博客_zsh 国内</a></p>
<p>参考文章：<a href="https://cloud.tencent.com/developer/article/1722062">CentOS 7.x 安装 ZSH 终端的配置方法 - 腾讯云开发者社区-腾讯云</a></p>
]]></content>
      <categories>
        <category>IT知识</category>
      </categories>
      <tags>
        <tag>技术知识</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>算法:剑指Offer</title>
    <url>/%E7%AE%97%E6%B3%95-%E5%89%91%E6%8C%87Offer/</url>
    <content><![CDATA[<p>    力扣算法题：剑指Offer。Java版本，算法解析和代码</p>
<span id="more"></span>

<h1 id="难度：简单"><a href="#难度：简单" class="headerlink" title="难度：简单"></a>难度：简单</h1><h2 id="数组中重复的数字-3"><a href="#数组中重复的数字-3" class="headerlink" title="数组中重复的数字-3"></a>数组中重复的数字-3</h2><blockquote>
<p>在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="题解思路"><a href="#题解思路" class="headerlink" title="题解思路"></a>题解思路</h3><p>题目只需要找到任意一个重复的数字，因此不需要使用排序的方法，也不需要使用额外的标记数组。可以将值为 i 的元素调整到第 i 个位置上，在不断替换排序的过程中寻找相同的数字，发现当前<u><strong>数字</strong></u>与<u><strong>数字下标</strong></u>数字相同时即中断程序。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || length &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前数字与下标符合，把当前 数字 与 当前数字下标值 交换</span></span><br><span class="line">            <span class="keyword">while</span> (nums[i] != i) &#123;</span><br><span class="line">                <span class="comment">// 如果发现当前 数字 与 数字下标值 相同，说明找到了重复数字</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] == nums[nums[i]]) &#123;</span><br><span class="line">                    <span class="keyword">return</span>  nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                swap(nums, i, nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两数交换方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="替换空格-5"><a href="#替换空格-5" class="headerlink" title="替换空格-5"></a>替换空格-5</h2><blockquote>
<p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof">https://leetcode.cn/problems/ti-huan-kong-ge-lcof</a></p>
</blockquote>
<h3 id="题解思路-1"><a href="#题解思路-1" class="headerlink" title="题解思路"></a>题解思路</h3><p>查找字符串的空格个数，并在其尾部添加相应的站位字符串，使之达到转换后的字符串长度。定义两个指针，P1指向原始字符串尾部下标，P2指向转换后字符串下标。判断P1是否为空格，如果为空格则把P2所指位置向前移动并修改其为替换字符串，如果不为空格则P2修改为P1所指的值。直到P1 &lt; 0或P1 &gt; P2</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str)</span><br><span class="line">        <span class="type">int</span> <span class="variable">P1</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= P1; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                s.apped(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">P2</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 直到P1 &lt; 0或P1 &gt; P2,结束算法。</span></span><br><span class="line">        <span class="keyword">while</span> (P1 &gt;= <span class="number">0</span> &amp;&amp; P1 &lt;= P2) &#123;</span><br><span class="line">            <span class="comment">// 得到P1的值并向前移动一位</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(P1--)</span><br><span class="line">            <span class="keyword">if</span> ( c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 把占位符替换为相应字符，并把P2向前移动</span></span><br><span class="line">                s.setCharAt(P2--, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                s.setCharAt(P2--, <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">                s.setCharAt(P2--, <span class="string">&#x27;%&#x27;</span>);                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.setCharAt(P2--, c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="从尾到头打印链表-6"><a href="#从尾到头打印链表-6" class="headerlink" title="从尾到头打印链表-6"></a>从尾到头打印链表-6</h2><blockquote>
<p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="题解思路-2"><a href="#题解思路-2" class="headerlink" title="题解思路"></a>题解思路</h3><h4 id="链表头插法"><a href="#链表头插法" class="headerlink" title="链表头插法"></a>链表头插法</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>建立一个新的链表，不断把原始链表的头节点插入新链表的头部。达到使链表倒序的结果。</p>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="comment">// 如果链表为空返回&#x27;[]&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// 计算链表长度，用来创建返回数组长度</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);    <span class="comment">// 创建带头节点的链表</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;    <span class="comment">// 只要不到head最后一个节点则不断插入。</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">m</span> <span class="operator">=</span> head.next;    <span class="comment">// 保存原始链表下一节点</span></span><br><span class="line">            head.next = p.next;    <span class="comment">// 插入head</span></span><br><span class="line">            p.next = head;    <span class="comment">// head完全插入p</span></span><br><span class="line">            head = m;    <span class="comment">// 原始链表头部指向下一节点</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从头遍历链表得到结果。</span></span><br><span class="line">        <span class="type">int</span>[] ret = <span class="keyword">new</span> <span class="title class_">int</span>[count];</span><br><span class="line">        p = p.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= count - <span class="number">1</span>; i++) &#123;</span><br><span class="line">           ret[i] = p.val;</span><br><span class="line">           p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>通过向下递归找到最末节点，返回时不断组合新的数组。</p>
<h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="comment">// 如果链表为空返回&#x27;[]&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果存在下一节点继续递归</span></span><br><span class="line">        <span class="keyword">if</span> (head.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建长度+1的数组，并复制上个数组的值</span></span><br><span class="line">            <span class="type">int</span>[] ints = reversePrint(head.next);</span><br><span class="line">            <span class="type">int</span>[] ints1 = Arrays.copyOf(ints, ints.length+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 在数组尾部添加当前值</span></span><br><span class="line">            ints1[ints.length] = head.val;</span><br><span class="line">            <span class="keyword">return</span> ints1;</span><br><span class="line">        <span class="comment">// 不存在下一节点，返回当前值并转化为数组int[]</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span>[] ints2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">            ints2[<span class="number">0</span>] = head.val;</span><br><span class="line">            <span class="keyword">return</span> ints2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h4><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>通过栈的特点，在遍历链表的时候将数据不断压栈，最后在出栈得到结果数组</p>
<h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 压栈</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.add(head.val);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ret = <span class="keyword">new</span> <span class="title class_">int</span>[stack.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 出栈</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            ret[i] = stack.pop();</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组倒序插入"><a href="#数组倒序插入" class="headerlink" title="数组倒序插入"></a>数组倒序插入</h4><h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>遍历链表得到结果数组长度。再次遍历链表并从数组尾部插入数据</p>
<h5 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">h</span> <span class="operator">=</span> head;    <span class="comment">// 保存链表的头部指针，以便再次遍历</span></span><br><span class="line">        <span class="keyword">while</span> (h.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            h = h.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] ret = <span class="keyword">new</span> <span class="title class_">int</span>[count];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> count-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ret[i] = head.val;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用两个栈实现队列-9"><a href="#用两个栈实现队列-9" class="headerlink" title="用两个栈实现队列-9"></a>用两个栈实现队列-9</h2><blockquote>
<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof">https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;CQueue&quot;</span>,<span class="string">&quot;appendTail&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>]</span><br><span class="line">[[],[<span class="number">3</span>],[],[]]</span><br><span class="line">输出：[<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">3</span>,-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="题解思路-3"><a href="#题解思路-3" class="headerlink" title="题解思路"></a>题解思路</h3><p>创建两个栈，一个用以存储队列的入队（in），一个用以出队（out）。当入队时对in进行入栈暂存；出队时判断out栈是否为空如国为空则将in的数据载入out，如若载入过后还为空说明队列为空返回-1，否则返回out出栈值。</p>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; in = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; out = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CQueue</span><span class="params">()</span> &#123;</span><br><span class="line">       in = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">       out = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTail</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">       in.push(value); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (out.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!in.isEmpty()) &#123;</span><br><span class="line">                out.push(in.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (out.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="斐波那契数列-10-1"><a href="#斐波那契数列-10-1" class="headerlink" title="斐波那契数列-10.1"></a>斐波那契数列-10.1</h2><blockquote>
<p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p>
<p>F(0) &#x3D; 0,   F(1) &#x3D; 1<br>F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>提示：</p>
<p>0 &lt;&#x3D; n &lt;&#x3D; 100</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof">https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line">输入：n = <span class="number">5</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="题解思路-4"><a href="#题解思路-4" class="headerlink" title="题解思路"></a>题解思路</h3><p>    当n小于等于1时直接返回，否则循环计算斐波那契数，计算时要对数进行取模以免超出范围。</p>
<h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> c;</span><br><span class="line">        <span class="keyword">while</span> (n &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            c = (a + b)%<span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">            n--;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="跳台阶-10-3"><a href="#跳台阶-10-3" class="headerlink" title="跳台阶-10.3"></a>跳台阶-10.3</h2><blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<p>数据范围：1≤<em>n</em>≤40</p>
<p>要求：时间复杂度O(n) ，空间复杂度： O(1)</p>
<p>链接：<a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tqId=11161&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">跳台阶_牛客题霸_牛客网</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>​    跳 n 阶台阶，可以先跳 1 阶台阶，再跳 n-1 阶台阶；或者先跳 2 阶台阶，再跳 n-2 阶台阶。而 n-1 和 n-2 阶台阶的跳法可以看成子问题，该问题的递推公式为：</p>
<p><img src="/%E7%AE%97%E6%B3%95-%E5%89%91%E6%8C%87Offer/2022-09-29-18-21-13-image.png"></p>
<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jumpFloor</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= <span class="number">2</span>) <span class="keyword">return</span> target;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(target &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">            target--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="旋转数组的最小数字-11"><a href="#旋转数组的最小数字-11" class="headerlink" title="旋转数组的最小数字-11"></a>旋转数组的最小数字-11</h2><blockquote>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p>
<p>给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。  </p>
<p>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof">https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：numbers = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>    将旋转数组对半分可以得到一个包含最小元素的新旋转数组，以及一个非递减排序的数组。新的旋转数组的数组元素是原数组的一半，从而将问题规模减少了一半，这种折半性质的算法的时间复杂度为 O(logN)。</p>
<p>    通过修改二分查找算法进行求解（l 代表 low，m 代表 mid，h 代表 high）：</p>
<p>    我们可以发现非递减组的头一定小于尾，以此可以区分旋转组的范围。如果numbers[m] &lt;&#x3D; numbers[h]则h &#x3D; m, 否则l &#x3D; m+1。 </p>
<p>    如果数组元素允许重复，会出现一个特殊的情况：nums[l] &#x3D;&#x3D; nums[m] &#x3D;&#x3D; nums[h]，此时无法确定解在哪个区间，需要切换到顺序查找。例如对于数组 {1,1,1,0,1}，l、m 和 h 指向的数都为 1，此时无法知道最小数字 0 在哪个区间。</p>
<h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minArray</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, h = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + (h - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[l] == numbers[m] &amp;&amp; numbers[m] == numbers[h]) &#123;</span><br><span class="line">                <span class="keyword">return</span> forMinArray(numbers, l, h);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[m] &lt;= numbers[h]) &#123;</span><br><span class="line">                h = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[l];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">forMinArray</span> <span class="params">(<span class="type">int</span>[] numbers, <span class="type">int</span> l, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l + <span class="number">1</span>; i &lt;= h; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i-<span class="number">1</span>] &gt; numbers[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> numbers[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打印从1到最大的n位数-17"><a href="#打印从1到最大的n位数-17" class="headerlink" title="打印从1到最大的n位数-17"></a>打印从1到最大的n位数-17</h2><blockquote>
<p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof">https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: n = <span class="number">1</span></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>    “位数”与”位数最大值“的关系 10^”位数”-1 &#x3D; ”位数最大值“。在通过for循环取值填入数组即完成解答。</p>
<h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] printNumbers(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pow</span> <span class="operator">=</span> (<span class="type">int</span>) Math.pow(<span class="number">10</span>, n);</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[pow -<span class="number">1</span> ];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; pow; i++) &#123;</span><br><span class="line">            result[i - <span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 n 可能会非常大，因此不能直接用 int 表示数字，而是用 char 数组进行存储。</p>
<p>使用回溯法得到所有的数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print1ToMaxOfNDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">char</span>[] number = <span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">        print1ToMaxOfNDigits(number, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print1ToMaxOfNDigits</span><span class="params">(<span class="type">char</span>[] number, <span class="type">int</span> digit)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (digit == number.length) &#123;</span><br><span class="line">            printNumber(number);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            number[digit] = (<span class="type">char</span>) (i + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            print1ToMaxOfNDigits(number, digit + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printNumber</span><span class="params">(<span class="type">char</span>[] number)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; number.length &amp;&amp; number[index] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            index++;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; number.length)</span><br><span class="line">            System.out.print(number[index++]);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除链表的节点-18"><a href="#删除链表的节点-18" class="headerlink" title="删除链表的节点-18"></a>删除链表的节点-18</h2><blockquote>
<p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<p>注意：此题对比原题有改动</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof">https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Definition for singly-linked list.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: head = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>], val = <span class="number">5</span></span><br><span class="line">输出: [<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>]</span><br><span class="line">解释: 给定你链表中值为 <span class="number">5</span> 的第二个节点，那么在调用了你的函数之后，该链表应变为 <span class="number">4</span> -&gt; <span class="number">1</span> -&gt; <span class="number">9.</span></span><br></pre></td></tr></table></figure>

<h3 id="题解思路-5"><a href="#题解思路-5" class="headerlink" title="题解思路"></a>题解思路</h3><p>    遍历链表，遇到目标节点则将下一个节点覆盖当前节点。</p>
<h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteNode</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head; </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val == val) &#123;</span><br><span class="line">                <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;    <span class="comment">//最后一个节点没有下一个节点，使上一节点的next为空</span></span><br><span class="line">                    tail.next = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 进行覆盖</span></span><br><span class="line">                head.val = head.next.val;</span><br><span class="line">                head.next = head.next.next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = head;    <span class="comment">// 保存上一个坐标</span></span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="调整数组顺序使奇数位于偶数前面-21"><a href="#调整数组顺序使奇数位于偶数前面-21" class="headerlink" title="调整数组顺序使奇数位于偶数前面-21"></a>调整数组顺序使奇数位于偶数前面-21</h2><blockquote>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>] </span><br><span class="line">注：[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>] 也是正确的答案之一。</span><br></pre></td></tr></table></figure>

<h3 id="题解思路-1"><a href="#题解思路-1" class="headerlink" title="题解思路-1"></a>题解思路-1</h3><p>​    对每个数组依次判断，再写入新的数组。</p>
<h3 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] exchange(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>, tail = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                result[head] = num;</span><br><span class="line">                head++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result[tail] = num;</span><br><span class="line">                tail--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路-2"></a>解题思路-2</h3><p>​    在原数组内创建两个指针head，tail。遍历数组时判断后交换。</p>
<h3 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] exchange(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != tail) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == head) i++;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[head];</span><br><span class="line">                nums[head] = nums[i];</span><br><span class="line">                nums[i] = num;</span><br><span class="line">                head++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[tail];</span><br><span class="line">                nums[tail] = nums[i];</span><br><span class="line">                nums[i] = num;</span><br><span class="line">                tail--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表中倒数第k个节点-22"><a href="#链表中倒数第k个节点-22" class="headerlink" title="链表中倒数第k个节点-22"></a>链表中倒数第k个节点-22</h2><blockquote>
<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p>
<p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof">https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof</a></p>
</blockquote>
<p>示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定一个链表: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>, 和 k = <span class="number">2.</span></span><br><span class="line"></span><br><span class="line">返回链表 <span class="number">4</span>-&gt;<span class="number">5.</span></span><br></pre></td></tr></table></figure>

<h3 id="题解思路-1-1"><a href="#题解思路-1-1" class="headerlink" title="题解思路-1"></a>题解思路-1</h3><p>​        目标节点位置&#x3D;链表长度-倒数节点数-1。遍历一次链表得到长度，即可计算节点位置，再次遍历即可得到目标节点。</p>
<h3 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - k; i++) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题解思路-2"><a href="#题解思路-2" class="headerlink" title="题解思路-2"></a>题解思路-2</h3><p>​        设链表的长度为 N。设置两个指针 P1 和 P2，先让 P1 移动 K 个节点，则还有 N - K 个节点可以移动。此时让 P1 和 P2 同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到第 N - K 个节点处，该位置就是倒数第 K 个节点。</p>
<h3 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">null</span> &amp;&amp; k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反转链表-24"><a href="#反转链表-24" class="headerlink" title="反转链表-24"></a>反转链表-24</h2><blockquote>
<p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<p>限制：<br>0 &lt;&#x3D; 节点个数 &lt;&#x3D; 5000</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof">https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof</a></p>
</blockquote>
<p>示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">输出: <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure>

<h3 id="题解思路-6"><a href="#题解思路-6" class="headerlink" title="题解思路"></a>题解思路</h3><p>​        定义两个指针，p1指向新链表的头，p2指向原链表的头。通过循环遍历将p2不断作为新链表的头往尾部插入p1实现链表反转。</p>
<h3 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> head.next;</span><br><span class="line"></span><br><span class="line">        p1.next = <span class="literal">null</span>;    <span class="comment">//初始化新链表的头</span></span><br><span class="line">        <span class="keyword">while</span> (p2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">p3</span> <span class="operator">=</span> p2.next;</span><br><span class="line">            p2.next = p1;    <span class="comment">//p2作为新链表的头，尾部插入p1</span></span><br><span class="line">            p1 = p2;    <span class="comment">//新链表头部重新置为p1</span></span><br><span class="line">            p2 = p3;    <span class="comment">//p2重新置为原链表头部</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合并两个排序的链表-25"><a href="#合并两个排序的链表-25" class="headerlink" title="合并两个排序的链表-25"></a>合并两个排序的链表-25</h2><blockquote>
<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof">https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof</a></p>
</blockquote>
<p><strong>示例1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">输出：<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure>

<h3 id="题解思路-7"><a href="#题解思路-7" class="headerlink" title="题解思路"></a>题解思路</h3><p>​        归并排序，通过对比两个链表的头部不断插入新链表进行排序。如果有剩余的链表再接入新链表尾部。</p>
<h3 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">result</span> <span class="operator">=</span> p;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">               p.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(l1.val);</span><br><span class="line">               l1 = l1.next;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               p.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(l2.val);</span><br><span class="line">               l2 = l2.next;</span><br><span class="line">           &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="literal">null</span>) </span><br><span class="line">            p.next = l1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            p.next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的镜像-27"><a href="#二叉树的镜像-27" class="headerlink" title="二叉树的镜像-27"></a>二叉树的镜像-27</h2><blockquote>
<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<p><img src="/./%E7%AE%97%E6%B3%95-%E5%89%91%E6%8C%87Offer/image-20221022113814681.png" alt="image-20221022113814681"></p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof">https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof</a></p>
</blockquote>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：root = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>]</span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<p>0 &lt;&#x3D; 节点个数 &lt;&#x3D; 1000</p>
<h3 id="题解思路-8"><a href="#题解思路-8" class="headerlink" title="题解思路"></a>题解思路</h3><p>​        通过递归到达二叉树的底部，对二叉树的左右子树进行交换。</p>
<h3 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归结束条件。已到达树的底端</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下递归</span></span><br><span class="line">        mirrorTree(root.left);</span><br><span class="line">        mirrorTree(root.right);</span><br><span class="line">        <span class="comment">// 交换左右子树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">t</span> <span class="operator">=</span> root.right;</span><br><span class="line">        root.right = root.left;</span><br><span class="line">        root.left = t;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对称的二叉树-28"><a href="#对称的二叉树-28" class="headerlink" title="对称的二叉树-28"></a>对称的二叉树-28</h2><blockquote>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<p>​      1<br>​    &#x2F; <br>  2   2<br> &#x2F; \ &#x2F; <br>3  4 4  3<br>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<p>​     1<br>   &#x2F; <br>  2   2<br>   \   <br>   3    3</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof">https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof</a></p>
</blockquote>
<h3 id="题解思路-9"><a href="#题解思路-9" class="headerlink" title="题解思路"></a>题解思路</h3><p>​        递归判断左右子树是否相同。</p>
<h3 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetrical</span><span class="params">(TreeNode pRoot)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetrical(pRoot.left, pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetrical</span><span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span> &amp;&amp; t2 == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span> || t2 == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1.val != t2.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetrical(t1.left, t2.right) &amp;&amp; isSymmetrical(t1.right, t2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="顺时针打印矩阵-29"><a href="#顺时针打印矩阵-29" class="headerlink" title="顺时针打印矩阵-29"></a>顺时针打印矩阵-29</h2><blockquote>
<p>难度简单462收藏分享切换为英文接收动态反馈</p>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/</a></p>
</blockquote>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>

<h3 id="题解思路-10"><a href="#题解思路-10" class="headerlink" title="题解思路"></a>题解思路</h3><p>​        根据行列下标、输出。</p>
<h3 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] spiralOrder(<span class="type">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] ret = <span class="keyword">new</span> <span class="title class_">int</span>[matrix[<span class="number">0</span>].length * matrix.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="number">0</span>, r2 = matrix.length - <span class="number">1</span>, c1 = <span class="number">0</span>, c2 = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (r1 &lt;= r2 &amp;&amp; c1 &lt;= c2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> c1; i &lt;= c2; i++)</span><br><span class="line">                ret[index++] = (matrix[r1][i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r1 + <span class="number">1</span>; i &lt;= r2; i++)</span><br><span class="line">                ret[index++] = (matrix[i][c2]);</span><br><span class="line">            <span class="keyword">if</span> (r1 != r2)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> c2 - <span class="number">1</span>; i &gt;= c1; i--)</span><br><span class="line">                    ret[index++] = (matrix[r2][i]);</span><br><span class="line">            <span class="keyword">if</span> (c1 != c2)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r2 - <span class="number">1</span>; i &gt; r1; i--)</span><br><span class="line">                    ret[index++] = (matrix[i][c1]);</span><br><span class="line">            r1++; r2--; c1++; c2--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="包含min函数的栈-30"><a href="#包含min函数的栈-30" class="headerlink" title="包含min函数的栈-30"></a>包含min函数的栈-30</h2><blockquote>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<p>提示：</p>
<p>各函数的调用总次数不超过 20000 次</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof">https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof</a></p>
</blockquote>
<p>示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MinStack</span> <span class="variable">minStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MinStack</span>();</span><br><span class="line">minStack.push(-<span class="number">2</span>);</span><br><span class="line">minStack.push(<span class="number">0</span>);</span><br><span class="line">minStack.push(-<span class="number">3</span>);</span><br><span class="line">minStack.min();   --&gt; 返回 -<span class="number">3.</span></span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 <span class="number">0.</span></span><br><span class="line">minStack.min();   --&gt; 返回 -<span class="number">2.</span></span><br></pre></td></tr></table></figure>

<h3 id="题解思路-11"><a href="#题解思路-11" class="headerlink" title="题解思路"></a>题解思路</h3><p>​        用min栈进行分段状态，在更小的数压入栈前，min栈保持当前状态（压入当前最小数）</p>
<h3 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; dataStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> node)</span> &#123;</span><br><span class="line">        dataStack.push(node);</span><br><span class="line">        minStack.push(minStack.isEmpty() ? node : Math.min(minStack.peek(), node));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        dataStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dataStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="从上到下打印二叉树-32-2"><a href="#从上到下打印二叉树-32-2" class="headerlink" title="从上到下打印二叉树-32.2"></a>从上到下打印二叉树-32.2</h2><blockquote>
<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<p> <img src="/./%E7%AE%97%E6%B3%95-%E5%89%91%E6%8C%87Offer/image-20221028113702347.png" alt="image-20221028113702347"></p>
<p>提示：</p>
<p>节点总数 &lt;&#x3D; 1000</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof">https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof</a></p>
</blockquote>
<h3 id="题解思路-12"><a href="#题解思路-12" class="headerlink" title="题解思路"></a>题解思路</h3><p>​        与从上到下打印二叉树-32.1思路一样，改变的只有在打印完一层后把列表加入总列表。</p>
<h3 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; treeNodes = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        treeNodes.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!treeNodes.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> treeNodes.size();</span><br><span class="line">            ArrayList&lt;Integer&gt; integers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (cnt-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">peek</span> <span class="operator">=</span> treeNodes.poll();</span><br><span class="line">                <span class="keyword">if</span> (peek == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                integers.add(peek.val);</span><br><span class="line">                treeNodes.add(peek.left);</span><br><span class="line">                treeNodes.add(peek.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!integers.isEmpty())</span><br><span class="line">                result.add(integers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="难度：中等"><a href="#难度：中等" class="headerlink" title="难度：中等"></a>难度：中等</h1><h2 id="二维数组中的查找-4"><a href="#二维数组中的查找-4" class="headerlink" title="二维数组中的查找-4"></a>二维数组中的查找-4</h2><blockquote>
<p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof">https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof</a></p>
</blockquote>
<h3 id="题解思路-13"><a href="#题解思路-13" class="headerlink" title="题解思路"></a>题解思路</h3><p>该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。</p>
<h3 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> matrix.length, cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 从右上角开始</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>, c = cols - <span class="number">1</span>; <span class="comment">// 下标</span></span><br><span class="line">        <span class="keyword">while</span> (r &lt;= rows - <span class="number">1</span> &amp;&amp; c &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == matrix[r][c])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; matrix[r][c])</span><br><span class="line">                r++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                c--;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重建二叉树-7"><a href="#重建二叉树-7" class="headerlink" title="重建二叉树-7"></a>重建二叉树-7</h2><blockquote>
<p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p>
<p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/">https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/</a></p>
</blockquote>
<p><img src="/%E7%AE%97%E6%B3%95-%E5%89%91%E6%8C%87Offer/2022-09-01-22-17-35-2022-09-01-21-41-25-image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: preorder = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>], inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line">Output: [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure>

<h3 id="题解思路-14"><a href="#题解思路-14" class="headerlink" title="题解思路"></a>题解思路</h3><p>前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。</p>
<h3 id="代码-24"><a href="#代码-24" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="comment">// 将中序遍历数组的值与下标存储在Map方便取用</span></span><br><span class="line">        <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; preorder.length; i++) &#123;</span><br><span class="line">                map.put(inorder[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> buildTree_2(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归地创建二叉树</span></span><br><span class="line">        <span class="keyword">public</span> TreeNode <span class="title function_">buildTree_2</span><span class="params">(<span class="type">int</span>[] pre, <span class="type">int</span> preL, <span class="type">int</span> preR, <span class="type">int</span> inL)</span> &#123;</span><br><span class="line">            <span class="comment">// 如果前序遍历的数组右下标大于左下标代表当前根为null，返回。</span></span><br><span class="line">            <span class="keyword">if</span> (preL &gt; preR) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[preL]);<span class="comment">// 前序遍历为“根左右”，pre的左下标值为根</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">indext</span> <span class="operator">=</span> map.get(root.val);    <span class="comment">// 中序遍历为“左根右”，前序的根将中序数组分为左右子树</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">leftTreeSize</span> <span class="operator">=</span> indext - inL;    <span class="comment">// 的到中序数组的大小</span></span><br><span class="line">            <span class="comment">// 划定左子树的范围，递归再次计算</span></span><br><span class="line">            root.left = buildTree_2(pre, preL + <span class="number">1</span>, preL + leftTreeSize, inL);</span><br><span class="line">            <span class="comment">// 划定右子树的范围，递归再次计算</span></span><br><span class="line">            root.right = buildTree_2(pre, preL + leftTreeSize + <span class="number">1</span>, preR, inL + leftTreeSize + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的下一个结点-8"><a href="#二叉树的下一个结点-8" class="headerlink" title="二叉树的下一个结点-8"></a>二叉树的下一个结点-8</h2><blockquote>
<p>给定一个二叉树其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的next指针。下图为一棵有9个节点的二叉树。树中从父节点指向子节点的指针用实线表示，从子节点指向父节点的用虚线表示</p>
<p>来源：牛客网(NowCoder)<br>链接：<a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">二叉树的下一个结点_牛客题霸_牛客网</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">&#123;<span class="number">8</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>&#125;,<span class="number">8</span></span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeLinkNode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">TreeLinkNode</span> <span class="variable">left</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeLinkNode</span> <span class="variable">right</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeLinkNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    TreeLinkNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题解思路-15"><a href="#题解思路-15" class="headerlink" title="题解思路"></a>题解思路</h3><p>中序顺序是“左根右”，给出一个节点为“根”，那下一跳应该遍历右子树。</p>
<p>如果节点的右子树不为空，那么该节点的下一个节点是右子树的最左节点，否则，向上找第一个左链接指向的树包含该节点的祖先节点。</p>
<h3 id="代码-25"><a href="#代码-25" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    TreeLinkNode left = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode right = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    TreeLinkNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeLinkNode <span class="title function_">GetNext</span><span class="params">(TreeLinkNode pNode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode.right != <span class="literal">null</span>) &#123;    <span class="comment">// 如果节点的右子树不为空</span></span><br><span class="line">            <span class="type">TreeLinkNode</span> <span class="variable">node</span> <span class="operator">=</span> pNode.right;</span><br><span class="line">            <span class="keyword">while</span> (node.left != <span class="literal">null</span>)    <span class="comment">// 找到最后一个左节点返回</span></span><br><span class="line">                node = node.left;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 如果节点的右子树为空,</span></span><br><span class="line">            <span class="keyword">while</span> (pNode.next != <span class="literal">null</span>) &#123;    <span class="comment">// 如果存在父节点</span></span><br><span class="line">                <span class="type">TreeLinkNode</span> <span class="variable">parent</span> <span class="operator">=</span> pNode.next;</span><br><span class="line">                <span class="keyword">if</span> (parent.left == pNode)    <span class="comment">// 如果父节点为根节点，则当前节点为下一节点</span></span><br><span class="line">                    <span class="keyword">return</span> parent;</span><br><span class="line">                pNode = pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="矩形覆盖-10-2"><a href="#矩形覆盖-10-2" class="headerlink" title="矩形覆盖-10.2"></a>矩形覆盖-10.2</h2><blockquote>
<p>我们可以用 2 * 1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2 * 1 的小矩形无重叠地覆盖一个 2 * n 的大矩形，从同一个方向看总共有多少种不同的方法？</p>
<p>数据范围：0≤n≤38 <br>进阶：空间复杂度 O(1)  ，时间复杂度 O(n)   </p>
<p>注意：约定 n &#x3D;&#x3D; 0 时，输出 0</p>
<p>链接：<a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&ru=/exam/oj">矩形覆盖_牛客题霸_牛客网</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="题解思路-16"><a href="#题解思路-16" class="headerlink" title="题解思路"></a>题解思路</h3><p>    要覆盖 2 * n 的大矩形，可以先覆盖 2<em>1 的矩形，再覆盖 2</em>(n-1) 的矩形；或者先覆盖 2 * 2 的矩形，再覆盖 2*(n-2) 的矩形。而覆盖 2*(n-1) 和 2*(n-2) 的矩形可以看成子问题。该问题的递推公式如下：</p>
<p><img src="/%E7%AE%97%E6%B3%95-%E5%89%91%E6%8C%87Offer/2022-09-28-18-23-04-image.png">    </p>
<h3 id="代码-26"><a href="#代码-26" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rectCover</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= <span class="number">1</span>) <span class="keyword">return</span> target;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> c;</span><br><span class="line">        <span class="keyword">while</span> (target &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            c = (a + b)%<span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">            target--;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="矩阵中的路径-12"><a href="#矩阵中的路径-12" class="headerlink" title="矩阵中的路径-12"></a>矩阵中的路径-12</h2><blockquote>
<p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p>例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。<br><img src="/%E7%AE%97%E6%B3%95-%E5%89%91%E6%8C%87Offer/image-20221003111728500.png"></p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof">https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof</a></p>
</blockquote>
<h3 id="题解思路-17"><a href="#题解思路-17" class="headerlink" title="题解思路"></a>题解思路</h3><p>​    使用回溯法（backtracking）进行求解，它是一种暴力搜索方法，通过搜索所有可能的结果来求解问题。回溯法在一次搜索结束时需要进行回溯（回退），将这一次搜索过程中设置的状态进行清除，从而开始一次新的搜索过程。例如下图示例中，从 f 开始，下一步有 4 种搜索可能，如果先搜索 b，需要将 b 标记为已经使用，防止重复使用。在这一次搜索结束之后，需要将 b 的已经使用状态清除，并搜索 c。</p>
<p><img src="/%E7%AE%97%E6%B3%95-%E5%89%91%E6%8C%87Offer/image-20221003111946629.png" alt="image-20221003111946629"></p>
<h3 id="代码-27"><a href="#代码-27" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i_len;    <span class="comment">//行长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> j_len;    <span class="comment">//列长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] next = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;    <span class="comment">//下标位移</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        i_len = board.length;</span><br><span class="line">        j_len = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">boolean</span>[][] marked = <span class="keyword">new</span> <span class="title class_">boolean</span>[i_len][j_len];    <span class="comment">//标记数组</span></span><br><span class="line">        <span class="type">char</span>[] word_char = word.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//    对方阵的每个位置为起点遍历寻找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; i_len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; j_len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (searchChar(board, marked, word_char, <span class="number">0</span>, i, j))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchChar</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">boolean</span>[][] marked,<span class="type">char</span>[] word_char, <span class="type">int</span> word_i, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (word_i == word_char.length)    <span class="comment">//    如果每个字符都找到，中断递归，返回true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 三个寻找错误条件：</span></span><br><span class="line"><span class="comment">            1.坐标超出范围</span></span><br><span class="line"><span class="comment">            2.当前字符不是目标字符</span></span><br><span class="line"><span class="comment">            3.当前字符是已遍历字符</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= i_len || j &lt; <span class="number">0</span> || j &gt;= j_len || board[i][j] != word_char[word_i] || marked[i][j])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        marked[i][j] = <span class="literal">true</span>; <span class="comment">// 对已遍历的字符进行标记</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] location : next) &#123;    <span class="comment">// 对四个方向进行下一步查找</span></span><br><span class="line">            <span class="keyword">if</span> (searchChar(board, marked, word_char, word_i+<span class="number">1</span>, i+location[<span class="number">0</span>], j+location[<span class="number">1</span>]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        marked[i][j] = <span class="literal">false</span>; <span class="comment">// 晦朔时，对寻找路径错误的字符标记进行复原</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="机器人的运动范围-13"><a href="#机器人的运动范围-13" class="headerlink" title="机器人的运动范围-13"></a>机器人的运动范围-13</h2><blockquote>
<p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7&#x3D;18。但它不能进入方格 [35, 38]，因为3+5+3+8&#x3D;19。请问该机器人能够到达多少个格子？</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof">https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：m = <span class="number">2</span>, n = <span class="number">3</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="题解思路-18"><a href="#题解思路-18" class="headerlink" title="题解思路"></a>题解思路</h3><p>    使用回溯法（backtracking）进行求解，它是一种暴力搜索方法，通过搜索所有可能的结果来求解问题。回溯法在一次搜索结束时需要进行回溯（回退）,从而开始一次新的搜索过程。</p>
<h3 id="代码-28"><a href="#代码-28" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[][] next = &#123;&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rows;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cols;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> threshold;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">cut</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rows = m;</span><br><span class="line">        <span class="built_in">this</span>.cols = n;</span><br><span class="line">        <span class="built_in">this</span>.threshold = k;</span><br><span class="line">        <span class="type">boolean</span>[][] marked = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];    <span class="comment">//用以标记路径</span></span><br><span class="line">        movePoint(marked, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> cut;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">movePoint</span><span class="params">(<span class="type">boolean</span>[][] marked, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols || !smaller(i, j) || marked[i][j]) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        marked[i][j] = <span class="literal">true</span>;    <span class="comment">//对已经查找过的路径进行标记，避免重复计算</span></span><br><span class="line">        cut++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] location : next) &#123;</span><br><span class="line">            movePoint(marked, i+location[<span class="number">0</span>], j+location[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">smaller</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> j;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!(r == <span class="number">0</span> &amp;&amp; c == <span class="number">0</span>)) &#123;</span><br><span class="line">            sum += c%<span class="number">10</span>;</span><br><span class="line">            c /= <span class="number">10</span>;</span><br><span class="line">            sum += r%<span class="number">10</span>;</span><br><span class="line">            r /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(sum);</span></span><br><span class="line">        <span class="keyword">return</span> sum &lt;= threshold;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剪绳子-14-1"><a href="#剪绳子-14-1" class="headerlink" title="剪绳子-14.1"></a>剪绳子-14.1</h2><blockquote>
<p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/jian-sheng-zi-lcof">https://leetcode.cn/problems/jian-sheng-zi-lcof</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">10</span></span><br><span class="line">输出: <span class="number">36</span></span><br><span class="line">解释: <span class="number">10</span> = <span class="number">3</span> + <span class="number">3</span> + <span class="number">4</span>, <span class="number">3</span> × <span class="number">3</span> × <span class="number">4</span> = <span class="number">36</span></span><br></pre></td></tr></table></figure>

<h3 id="题解思路-19"><a href="#题解思路-19" class="headerlink" title="题解思路"></a>题解思路</h3><p>    尽可能多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现。如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。</p>
<p>证明：当 n &gt;&#x3D; 5 时，3(n - 3) - n &#x3D; 2n - 9 &gt; 0，且 2(n - 2) - n &#x3D; n - 4 &gt; 0。因此在 n &gt;&#x3D; 5 的情况下，将绳子剪成一段为 2 或者 3，得到的乘积会更大。又因为 3(n - 3) - 2(n - 2) &#x3D; n - 5 &gt;&#x3D; 0，所以剪成一段长度为 3 比长度为 2 得到的乘积更大。</p>
<h3 id="代码-29"><a href="#代码-29" class="headerlink" title="代码"></a>代码</h3><p>贪心法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution_1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">timesOf3</span> <span class="operator">=</span> n / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (n - timesOf3 * <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line">            timesOf3--;</span><br><span class="line">        <span class="type">int</span> <span class="variable">timesOf2</span> <span class="operator">=</span> (n - timesOf3 * <span class="number">3</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (Math.pow(<span class="number">3</span>, timesOf3)) * (<span class="type">int</span>) (Math.pow(<span class="number">2</span>, timesOf2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态规划</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution_2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(j * (i - j), dp[j] * (i - j)));</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二进制中-1-的个数-15"><a href="#二进制中-1-的个数-15" class="headerlink" title="二进制中 1 的个数-15"></a>二进制中 1 的个数-15</h2><blockquote>
<p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 汉明重量).）。</p>
<p> </p>
<p>提示：</p>
<p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof">https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">11</span> (控制台输入 <span class="number">00000000000000000000000000001011</span>)</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：输入的二进制串 <span class="number">00000000000000000000000000001011</span> 中，共有三位为 <span class="string">&#x27;1&#x27;</span>。</span><br></pre></td></tr></table></figure>

<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>该位运算去除 n 的位级表示中最低的那一位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">n       : <span class="number">10110100</span></span><br><span class="line">n-<span class="number">1</span>     : <span class="number">10110011</span></span><br><span class="line">n&amp;(n-<span class="number">1</span>) : <span class="number">10110000</span></span><br></pre></td></tr></table></figure>

<h3 id="代码-30"><a href="#代码-30" class="headerlink" title="代码"></a>代码</h3><p>时间复杂度：O(M)，其中 M 表示 1 的个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内置函数实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数值的整数次方-16"><a href="#数值的整数次方-16" class="headerlink" title="数值的整数次方-16"></a>数值的整数次方-16</h2><blockquote>
<p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。    </p>
<p>来源：<a href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">力扣</a></p>
</blockquote>
<h3 id="题解思路-20"><a href="#题解思路-20" class="headerlink" title="题解思路"></a>题解思路</h3><p>    下面的讨论中 x 代表底数，n 代表指数。</p>
<p><img src="/%E7%AE%97%E6%B3%95-%E5%89%91%E6%8C%87Offer/2022-10-10-15-34-00-image.png"></p>
<h3 id="代码-31"><a href="#代码-31" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)  <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isNegative</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            n = -n;</span><br><span class="line">            isNegative = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// int的范围是-2147483648~2147483647 防止负数的时候翻转出错</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">exponent</span> <span class="operator">=</span> n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (isNegative &amp;&amp; n == -<span class="number">2147483648</span>) exponent = <span class="number">1073741824</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">base</span> <span class="operator">=</span> x * x</span><br><span class="line">        <span class="type">double</span> <span class="variable">pow</span> <span class="operator">=</span> myPow(base, exponent);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            pow = pow * x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断指数的正反。是否翻转计算 a^-n = 1/a^n</span></span><br><span class="line">        <span class="keyword">return</span> isNegative ? <span class="number">1</span>/pow : pow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="表示数值的字符串-20"><a href="#表示数值的字符串-20" class="headerlink" title="表示数值的字符串-20"></a>表示数值的字符串-20</h2><blockquote>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。</p>
<p>数值（按顺序）可以分成以下几个部分：</p>
<ol>
<li><p>若干空格</p>
</li>
<li><p>一个 小数 或者 整数</p>
</li>
<li><p>（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 整数</p>
</li>
<li><p>若干空格</p>
</li>
</ol>
<p>小数（按顺序）可以分成以下几个部分：</p>
<ol>
<li><p>（可选）一个符号字符（’+’ 或 ‘-‘）</p>
</li>
<li><p>下述格式之一：</p>
<ol>
<li>至少一位数字，后面跟着一个点 ‘.’</li>
<li>至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字</li>
<li>一个点 ‘.’ ，后面跟着至少一位数字</li>
</ol>
</li>
</ol>
<p>整数（按顺序）可以分成以下几个部分：</p>
<ol>
<li><p>（可选）一个符号字符（’+’ 或 ‘-‘）</p>
</li>
<li><p>至少一位数字</p>
</li>
</ol>
<p>部分数值列举如下：</p>
<ul>
<li>[“+100”, “5e2”, “-123”, “3.1416”, “-1E-16”, “0123”]</li>
</ul>
<p>部分非数值列举如下：</p>
<ul>
<li>[“12e”, “1a3.14”, “1.2.3”, “+-5”, “12e+5.4”]</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof">https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof</a></p>
</blockquote>
<p>示例 1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;0&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;e&quot;</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;.&quot;</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>示例 4：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;    .1  &quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="题解思路-21"><a href="#题解思路-21" class="headerlink" title="题解思路"></a>题解思路</h3><p>​    本题使用有限状态自动机。根据字符类型和合法数值的特点，先定义状态，再画出状态转移图，最后编写代码即可。</p>
<p>详解链接：<a href="https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/mian-shi-ti-20-biao-shi-shu-zhi-de-zi-fu-chuan-y-2/">https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/mian-shi-ti-20-biao-shi-shu-zhi-de-zi-fu-chuan-y-2/</a></p>
<h3 id="代码-32"><a href="#代码-32" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNumber</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map[] states = &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;() &#123;&#123; put(<span class="string">&#x27; &#x27;</span>, <span class="number">0</span>); put(<span class="string">&#x27;s&#x27;</span>, <span class="number">1</span>); put(<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>); put(<span class="string">&#x27;.&#x27;</span>, <span class="number">4</span>); &#125;&#125;, <span class="comment">// 0.</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>); put(<span class="string">&#x27;.&#x27;</span>, <span class="number">4</span>); &#125;&#125;,                           <span class="comment">// 1.</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>); put(<span class="string">&#x27;.&#x27;</span>, <span class="number">3</span>); put(<span class="string">&#x27;e&#x27;</span>, <span class="number">5</span>); put(<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>); &#125;&#125;, <span class="comment">// 2.</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">3</span>); put(<span class="string">&#x27;e&#x27;</span>, <span class="number">5</span>); put(<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>); &#125;&#125;,              <span class="comment">// 3.</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">3</span>); &#125;&#125;,                                        <span class="comment">// 4.</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;() &#123;&#123; put(<span class="string">&#x27;s&#x27;</span>, <span class="number">6</span>); put(<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>); &#125;&#125;,                           <span class="comment">// 5.</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>); &#125;&#125;,                                        <span class="comment">// 6.</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>); put(<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>); &#125;&#125;,                           <span class="comment">// 7.</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;() &#123;&#123; put(<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>); &#125;&#125;                                         <span class="comment">// 8.</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) t = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>) t = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;E&#x27;</span>) t = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;.&#x27;</span> || c == <span class="string">&#x27; &#x27;</span>) t = c;</span><br><span class="line">            <span class="keyword">else</span> t = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!states[p].containsKey(t)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = (<span class="type">int</span>)states[p].get(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p == <span class="number">2</span> || p == <span class="number">3</span> || p == <span class="number">7</span> || p == <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用正则表达式</p>
<blockquote>
<p>不完全解答，无法判断e是否飞开头，e后是否有空格</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNumeric</span><span class="params">(<span class="type">char</span>[] str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(str).matches(<span class="string">&quot;[+-]?\\d*(\\.\\d+)?([eE][+-]?\\d+)?&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树的子结构-26"><a href="#树的子结构-26" class="headerlink" title="树的子结构-26"></a>树的子结构-26</h2><blockquote>
<p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<p><img src="/./%E7%AE%97%E6%B3%95-%E5%89%91%E6%8C%87Offer/image-20221021115349035.png" alt="image-20221021115349035"></p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof">https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof</a></p>
</blockquote>
<p><strong>示例 1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], B = [<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2 ：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：A = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>], B = [<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<p><code>0 &lt;= 节点个数 &lt;= 10000</code></p>
<h3 id="题解思路-22"><a href="#题解思路-22" class="headerlink" title="题解思路"></a>题解思路</h3><h3 id="代码-33"><a href="#代码-33" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubStructure</span> <span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span> || root2 == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSubtreeWithRoot(root1, root2) || isSubStructure(root1.left, root2) || isSubStructure(root1.right, root2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSubtreeWithRoot</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root1.val != root2.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSubtreeWithRoot(root1.left, root2.left) &amp;&amp; isSubtreeWithRoot(root1.right, root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈的压入弹出序列-31"><a href="#栈的压入弹出序列-31" class="headerlink" title="栈的压入弹出序列-31"></a>栈的压入弹出序列-31</h2><blockquote>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof">https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof</a></p>
</blockquote>
<p>示例 1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：pushed = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], popped = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(<span class="number">1</span>), push(<span class="number">2</span>), push(<span class="number">3</span>), push(<span class="number">4</span>), pop() -&gt; <span class="number">4</span>,</span><br><span class="line">push(<span class="number">5</span>), pop() -&gt; <span class="number">5</span>, pop() -&gt; <span class="number">3</span>, pop() -&gt; <span class="number">2</span>, pop() -&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：pushed = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], popped = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：<span class="number">1</span> 不能在 <span class="number">2</span> 之前弹出。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> &lt;= pushed.length == popped.length &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">0</span> &lt;= pushed[i], popped[i] &lt; <span class="number">1000</span></span><br><span class="line">pushed 是 popped 的排列。</span><br></pre></td></tr></table></figure>

<h3 id="题解思路-23"><a href="#题解思路-23" class="headerlink" title="题解思路"></a>题解思路</h3><p>使用一个栈来模拟压入弹出操作。</p>
<h3 id="代码-34"><a href="#代码-34" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateStackSequences</span><span class="params">(<span class="type">int</span>[] pushed, <span class="type">int</span>[] popped)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> pushed.length;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">pushedIndex</span> <span class="operator">=</span> <span class="number">0</span>, poppedIndex = <span class="number">0</span>; pushedIndex &lt; n; pushedIndex++) &#123;</span><br><span class="line">            stack.push(pushed[pushedIndex]);</span><br><span class="line">            <span class="keyword">while</span> (poppedIndex &lt; n &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek() == popped[poppedIndex]) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                poppedIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="从上到下打印二叉树-32-1"><a href="#从上到下打印二叉树-32-1" class="headerlink" title="从上到下打印二叉树-32.1"></a>从上到下打印二叉树-32.1</h2><blockquote>
<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<p> <img src="/./%E7%AE%97%E6%B3%95-%E5%89%91%E6%8C%87Offer/image-20221027133053021.png" alt="image-20221027133053021"></p>
<p>提示：</p>
<p>节点总数 &lt;&#x3D; 1000</p>
<p>   来源：力扣（LeetCode）<br> 链接：<a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof">https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof</a></p>
</blockquote>
<h3 id="题解思路-24"><a href="#题解思路-24" class="headerlink" title="题解思路"></a>题解思路</h3><ul>
<li>实现过程<br>  1、首先将二叉树的根节点push到队列中，判断队列不为NULL，就输出队头的元素，<br>  2、判断节点如果有孩子，就将孩子push到队列中，<br>  3、遍历过的节点出队列，<br>  4、循环以上操作，直到Tree &#x3D;&#x3D; NULL。</li>
</ul>
<h3 id="代码-35"><a href="#代码-35" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 对每一层进行入队出队</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span> (cnt-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">t</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 将当前层节点加入数组，并将子节点加入队列</span></span><br><span class="line">                ret.add(t.val);</span><br><span class="line">                queue.add(t.left);</span><br><span class="line">                queue.add(t.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] d = <span class="keyword">new</span> <span class="title class_">int</span>[ret.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;ret.size();i++)&#123;</span><br><span class="line">            d[i] = ret.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="从上到下打印二叉树-32-3"><a href="#从上到下打印二叉树-32-3" class="headerlink" title="从上到下打印二叉树-32.3"></a>从上到下打印二叉树-32.3</h2><blockquote>
<p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<p><img src="/./%E7%AE%97%E6%B3%95-%E5%89%91%E6%8C%87Offer/image-20221029182308388.png" alt="image-20221029182308388"></p>
<p><strong>提示：</strong></p>
<ol>
<li><code>节点总数 &lt;= 1000</code></li>
</ol>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/</a></p>
</blockquote>
<h3 id="题解思路-25"><a href="#题解思路-25" class="headerlink" title="题解思路"></a>题解思路</h3><p>​        在从上到<a href="#%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-32.2">下打印二叉树-32.2</a>的基础上判断每一层是否该翻转。</p>
<h3 id="代码-36"><a href="#代码-36" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">parity</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            ArrayList&lt;Integer&gt; floor = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (cnt-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                floor.add(node.val);</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            parity ！= parity;</span><br><span class="line">            <span class="keyword">if</span> (!floor.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (parity) <span class="comment">// 判断是否该翻转数组。</span></span><br><span class="line">                    Collections.reverse(floor);</span><br><span class="line">                result.add(floor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉搜索树的后序遍历序列-33"><a href="#二叉搜索树的后序遍历序列-33" class="headerlink" title="二叉搜索树的后序遍历序列-33"></a>二叉搜索树的后序遍历序列-33</h2><blockquote>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p>
<p> <img src="/./%E7%AE%97%E6%B3%95-%E5%89%91%E6%8C%87Offer/image-20221030112800696.png" alt="image-20221030112800696"></p>
<p>提示：</p>
<p>数组长度 &lt;&#x3D; 1000</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof">https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof</a></p>
</blockquote>
<h3 id="题解思路-26"><a href="#题解思路-26" class="headerlink" title="题解思路"></a>题解思路</h3><p>​        后序遍历二叉搜索树：树的左子树比根小，右子树比根大。后续遍历数组最后一个为根，依次为根据递归遍历数组。</p>
<h3 id="代码-37"><a href="#代码-37" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verifyPostorder</span><span class="params">(<span class="type">int</span>[] sequence)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence == <span class="literal">null</span> || sequence.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> verify(sequence, <span class="number">0</span>, sequence.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">verify</span><span class="params">(<span class="type">int</span>[] sequence, <span class="type">int</span> first, <span class="type">int</span> last)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (last - first &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> sequence[last];    <span class="comment">//当前树的根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cutIndex</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="keyword">while</span> (cutIndex &lt; last &amp;&amp; sequence[cutIndex] &lt;= rootVal)    <span class="comment">//搜索左子树的范围</span></span><br><span class="line">            cutIndex++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cutIndex; i &lt; last; i++)    <span class="comment">//按照规则其右子树应该都大于根，否则返回false</span></span><br><span class="line">            <span class="keyword">if</span> (sequence[i] &lt; rootVal)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> verify(sequence, first, cutIndex - <span class="number">1</span>) &amp;&amp; verify(sequence, cutIndex, last - <span class="number">1</span>);    <span class="comment">//递归搜索</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="难度：困难"><a href="#难度：困难" class="headerlink" title="难度：困难"></a>难度：困难</h1><h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h2><blockquote>
<p>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof">https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">&quot;aa&quot;</span></span><br><span class="line">p = <span class="string">&quot;a&quot;</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: <span class="string">&quot;a&quot;</span> 无法匹配 <span class="string">&quot;aa&quot;</span> 整个字符串。</span><br></pre></td></tr></table></figure>

<h3 id="题解思路-27"><a href="#题解思路-27" class="headerlink" title="题解思路"></a>题解思路</h3><p>    应该注意到，’.’ 是用来当做一个任意字符，而 ‘<em>‘ 是用来重复前面的字符。这两个的作用不同，不能把 ‘.’ 的作用和 ‘</em>‘ 进行类比，从而把它当成重复前面字符一次。</p>
<p>    假设主串为 AA，模式串为 BB 从最后一步出发，需要关注最后进来的字符。假设 AA 的长度为 nn ，BB 的长度为 mm ，关注正则表达式 BB 的最后一个字符是谁，它有三种可能，正常字符、∗ 和 .（点），那针对这三种情况讨论即可，如下：</p>
<ol>
<li><p>如果 BB 的最后一个字符是正常字符，那就是看 A[n-1]A[n−1] 是否等于 B[m-1]B[m−1]，相等则看 A0..n−2​ 与B0..m−2​，不等则是不能匹配，这就是子问题。</p>
</li>
<li><p>如果 B 的最后一个字符是<code>.</code>，它能匹配任意字符，直接看 A0..n−2​ 与 B0..m−2​</p>
</li>
<li><p>如果 B 的最后一个字符是<code>*</code>它代表 B[m−2]&#x3D;c 可以重复0次或多次，它们是一个整体 c∗</p>
<ul>
<li><p>情况一：A[n-1]A[n−1] 是 00 个 cc，BB 最后两个字符废了，能否匹配取决于 A0..n−1​ 和 B0..m−3​ 是否匹配</p>
</li>
<li><p>情况二：A[n−1] 是多个 c 中的最后一个（这种情况必须 A[n−1]&#x3D;c 或者 c&#x3D;′.′），所以 A 匹配完往前挪一个，B 继续匹配，因为可以匹配多个，继续看 A0..n−2​ 和 B0..m−1​是否匹配。</p>
</li>
</ul>
</li>
</ol>
<h3 id="代码-38"><a href="#代码-38" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] pattern = p.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> str.length, n = pattern.length;</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span> (pattern[i - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                <span class="keyword">if</span> (str[i - <span class="number">1</span>] == pattern[j - <span class="number">1</span>] || pattern[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pattern[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                    <span class="keyword">if</span> (pattern[j - <span class="number">2</span>] == str[i - <span class="number">1</span>] || pattern[j - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                        dp[i][j] |= dp[i][j - <span class="number">1</span>]; <span class="comment">// a* counts as single a</span></span><br><span class="line">                        dp[i][j] |= dp[i - <span class="number">1</span>][j]; <span class="comment">// a* counts as multiple a</span></span><br><span class="line">                        dp[i][j] |= dp[i][j - <span class="number">2</span>]; <span class="comment">// a* counts as empty</span></span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        dp[i][j] = dp[i][j - <span class="number">2</span>];   <span class="comment">// a* only counts as empty</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>github：<a href="https://github.com/CyC2018/CS-Notes">https://github.com/CyC2018/CS-Notes</a></p>
<p>力扣：<a href="https://leetcode.cn/">https://leetcode.cn/</a></p>
<p>牛客：<a href="https://www.nowcoder.com/">https://www.nowcoder.com/</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>更新中</tag>
        <tag>算法</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL:查询连续n天登录的用户</title>
    <url>/SQL-%E6%9F%A5%E8%AF%A2%E8%BF%9E%E7%BB%ADn%E5%A4%A9%E7%99%BB%E5%BD%95%E7%9A%84%E7%94%A8%E6%88%B7/</url>
    <content><![CDATA[<p>        使用 MySQL 解决用户连续n天登录的问题</p>
<span id="more"></span>

<h1 id="测试数据集"><a href="#测试数据集" class="headerlink" title="测试数据集"></a>测试数据集</h1><p>建表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- `t`</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> `t`</span><br><span class="line">(</span><br><span class="line">`uid` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">`login_time` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;时间&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;`t`&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>导入测试数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;2022-10-30&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;2022-10-3&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;2022-10-18&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2022-10-2&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;2022-10-1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;2022-10-28&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;2022-10-2&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;2022-10-1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;2022-10-2&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2022-10-30&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;2022-10-30&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;2022-10-4&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;2022-10-30&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;2022-10-18&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;2022-10-5&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;2022-10-30&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;2022-10-3&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;2022-10-30&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2022-10-30&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;2022-10-3&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;2022-10-8&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;2022-10-18&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;2022-10-1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;2022-10-2&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;2022-10-30&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;2022-10-9&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2022-10-4&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;2022-10-30&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;2022-10-8&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;2022-10-8&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;2022-10-7&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2022-10-21&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;2022-10-30&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;2022-10-9&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;2022-10-30&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;2022-10-5&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;2022-10-1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;2022-10-30&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;2022-10-19&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;2022-10-6&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;2022-10-7&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;2022-10-27&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;2022-10-5&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;2022-10-9&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;2022-10-30&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;2022-10-8&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2022-10-3&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;2022-10-12&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;2022-10-3&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;2022-10-21&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;2022-10-2&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2022-10-3&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;2022-10-7&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;2022-10-30&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2022-10-5&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;2022-10-3&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;2022-10-30&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;2022-10-12&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;2022-10-1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;2022-10-23&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;2022-10-3&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;2022-10-6&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;2022-10-15&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;2022-10-30&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;2022-10-30&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;2022-10-9&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;2022-10-2&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;2022-10-30&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;2022-10-30&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;2022-10-4&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;2022-10-5&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;2022-10-9&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;2022-10-6&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;2022-10-30&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;2022-10-7&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;2022-10-5&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2022-10-5&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2022-10-1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;2022-10-5&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;2022-10-29&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;2022-10-6&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;2022-10-5&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;2022-10-18&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;2022-10-2&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;2022-10-11&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2022-10-30&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;2022-10-30&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;2022-10-30&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;2022-10-28&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;2022-10-5&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;2022-10-23&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;2022-10-1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;2022-10-1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;2022-10-2&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2022-10-15&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;2022-10-9&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;2022-10-24&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;2022-10-1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;2022-10-4&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t` (`uid`, `login_time`) <span class="keyword">values</span> (<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;2022-10-2&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="使用-lag-函数解"><a href="#使用-lag-函数解" class="headerlink" title="使用 lag() 函数解"></a>使用 lag() 函数解</h1><blockquote>
<p>以连续登录5天为例</p>
</blockquote>
<p>在MySQL-8.0中使用WITH建立临时表可以使代码清晰。</p>
<p>表<code>t1</code>的作用是过滤相同时间段同一个用户多次登录。</p>
<p>表<code>t2</code>的作用是查询连续登录的日期；使用 OVER 以<code>uid</code>进行分区并以<code>ymd</code>进行排序开窗显示 lag 函数( <code>ymd</code>在<code>t1</code>表 中的小且第4大的日期，如果没有则为null)；再使用 datediff 函数(<code>ymd</code>与 lag函数的差值)显示差值，如果值为4则表示该用户连续登录了5天</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> </span><br><span class="line">t1 <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> uid, <span class="type">date</span>(login_time) ymd</span><br><span class="line">    <span class="keyword">FROM</span> t</span><br><span class="line">    <span class="keyword">WHERE</span> login_time <span class="keyword">BETWEEN</span> <span class="type">timestamp</span> <span class="string">&#x27;2022-10-01 00:00:00&#x27;</span> <span class="keyword">AND</span> <span class="type">timestamp</span> <span class="string">&#x27;2022-10-31 23:59:59&#x27;</span></span><br><span class="line">),</span><br><span class="line">t2 <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> uid, ymd, datediff(ymd, <span class="built_in">lag</span>(ymd, <span class="number">4</span>) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> uid <span class="keyword">ORDER</span> <span class="keyword">BY</span> ymd)) diff</span><br><span class="line">    <span class="keyword">FROM</span> t1</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> uid, date_sub(ymd, <span class="type">INTERVAL</span> <span class="number">4</span> <span class="keyword">DAY</span>) min_date, myd</span><br><span class="line"><span class="keyword">FROM</span> t2</span><br><span class="line"><span class="keyword">WHERE</span> diff <span class="operator">=</span> <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<h1 id="使用-row-number-函数解"><a href="#使用-row-number-函数解" class="headerlink" title="使用 row_number() 函数解"></a>使用 row_number() 函数解</h1><blockquote>
<p>以连续登录5天为例</p>
</blockquote>
<p>在MySQL-8.0中使用WITH建立临时表可以使代码清晰。</p>
<p>表<code>t1</code>的作用是过滤相同时间段同一个用户多次登录。</p>
<p>表<code>t2</code>的作用是查询连续登录的日期；使用 OVER 以<code>uid</code>进行分区并以<code>ymd</code>进行排序开窗显示 row_number 函数(从1开始排序)；再使用 INTERVAL 关键字取 DAY 的间隔日期数组，最后使用 date_sub 函数显示间隔时间后的日期，如果日期是连续的则日期应该相同；最后进行分组即可得到连续天数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span></span><br><span class="line">t1 <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> uid, <span class="type">date</span>(login_time) ymd)</span><br><span class="line">    <span class="keyword">FROM</span> t</span><br><span class="line">    <span class="keyword">WHERE</span> login_time <span class="keyword">BETWEEN</span> <span class="type">timestamp</span> <span class="string">&#x27;2022-10-01 00:00:00&#x27;</span> <span class="keyword">AND</span> <span class="type">timestamp</span> <span class="string">&#x27;2022-10-31 23:59:59&#x27;</span></span><br><span class="line">),</span><br><span class="line">t2 <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> uid, ymd, date_sub(ymd, <span class="type">INTERVAL</span> <span class="built_in">row_number</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> uid <span class="keyword">ORDER</span> <span class="keyword">BY</span> ymd) <span class="keyword">DAY</span>) sub_date</span><br><span class="line">    <span class="keyword">FROM</span> t1</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> uid, <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> t2</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> uid, sub_date;</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>IT知识</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
</search>
